<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>JSC Internal:From JS Source To Bytecode | fchain7&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="I’ve researched about jsc for a long time by analyzing bugs, but all of them are just scattered learning without systematic analysis. To become more professional, i decide to audit the jsc code from t">
<meta property="og:type" content="article">
<meta property="og:title" content="JSC Internal:From JS Source To Bytecode">
<meta property="og:url" content="http://example.com/2021/12/11/2021-12-11-JSC-Internal-From-JS-Source-To-Bytecode/index.html">
<meta property="og:site_name" content="fchain7&#39;s blog">
<meta property="og:description" content="I’ve researched about jsc for a long time by analyzing bugs, but all of them are just scattered learning without systematic analysis. To become more professional, i decide to audit the jsc code from t">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-12-12T03:27:35.000Z">
<meta property="article:modified_time" content="2021-12-13T05:12:11.233Z">
<meta property="article:author" content="fchain7">
<meta property="article:tag" content="jsc">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="fchain7&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Noto+Sans+KR:100,300,400,700&amp;subset=korean" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <!--<div id="banner"></div>-->
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        <a href="/" id="main-nav-title" class="main-nav-link">fchain7&#39;s blog</a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives/">Archives</a>
        
          <a class="main-nav-link" href="/about/">about</a>
        
      </nav>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-2021-12-11-JSC-Internal-From-JS-Source-To-Bytecode" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Browser/">Browser</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      JSC Internal:From JS Source To Bytecode
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>I’ve researched about jsc for a long time by analyzing bugs, but all of them are just scattered learning without systematic analysis. To become more professional, i decide to audit the jsc code from the very begining to the end including parser, lint, dfg.</p>
<p>These should be series of posts and this is the first post which covers how to compile js souce code to bytecode. Thanks very much for those who are willing to share the research publicly, especially <a target="_blank" rel="noopener" href="https://zon8.re/">Zon8 Research</a> team, it helps me a lot.</p>
<p>Before getting into this paper, i strongly suggest that you should read official article <a target="_blank" rel="noopener" href="https://webkit.org/blog/9329/a-new-bytecode-format-for-javascriptcore/">A New Bytecode Format for JavaScriptCore</a> fist which  explains the bytecode in very detail. In this post, i’ll take you as knowing the basic knowledge about bytecode as default.</p>
<h2 id="Workflow"><a href="#Workflow" class="headerlink" title="Workflow"></a>Workflow</h2><p>Let me give you a overall workflow about compiling js to bytecode. In general, the whole process can be concluded as four parts:</p>
<ol>
<li>Initialize the runtime.</li>
<li>Parse to AST</li>
<li>Generate unlinked bytecode</li>
<li>Generate linked bytecode</li>
<li>Ready to execute bytecode</li>
</ol>
<p>The jsc tries to initialize the runtime at first, it initializes <code>WTF</code> framework and sets the runtime flag according to command line arguments, it also creates the <code>VM</code> object for the process, and most importantly, generates <code>globalObject</code> object, which is responsible for initializing the required builtins and other runtime setup activities. At last it will read js code to memory form file.</p>
<p>After initializing the runtime, it will try to lex and parse the js source to AST. It first initializes a <code>parser</code> object, and then build a <code>ASTBuilder</code> to store the <code>AST</code>. The <code>parser</code>  loops to lex the souce code,  parse it to <code>statement</code>(<code> ast node</code>), append the <code>statement </code> to <code>ASTBuilder</code>, and go back to lex. In the end, it builds a <code>AST</code> tree.</p>
<p>When the <code>AST</code> tree is generated, jsc will try to generate <code>unlinked</code> bytecode(<code>unlinkedCodeBlock</code>) with the <code>AST</code> tree. At first, it will build a <code>BytecodeGenerator</code> object which is responsible for traverse every <code>AST</code> node and generate corresponding bytecode. The <code>BytecodeGenerator</code> will first emit bytecode for the program prologue, and then traverse every <code>ast</code> node and generate corresponding bytecode. At last it will call <code>finalize</code> function to finish the generation of the <code>unlinkedCodeBlock</code> object.</p>
<p>After that, jsc will try to link the <code>unlinked</code> bytecode and generate the <code>linked</code> bytecode. It will traverse every <code>unlinked</code> bytecode and link it to code block, it will also build the <code>Metadata table</code> for the bytecode in this process.</p>
<p>When finished the generation of <code>linked</code> bytecode, it will set the code object to entry point, and set up the program frame to execute, now jsc can goes into the <code>LLInt</code> to interpreter the <code>bytecode</code>.</p>
<p>In the next chapters, i’ll dive into the source code to explain the upper processes. For brievity, i’ll truncate the code as much as possible, and only leave the key code.</p>
<p>I read the source code with debugging the <code>jsc</code> in gdb, the source code is shown as follow:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filename: demo.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> z = x + y;</span><br></pre></td></tr></table></figure>

<h2 id="Initialize-the-runtime"><a href="#Initialize-the-runtime" class="headerlink" title="Initialize the runtime"></a>Initialize the runtime</h2><p>Now we go into the first part to see how jsc initialize the runtime. </p>
<p>The entry point is <code>jscmain</code> function which is called by <code>main</code>. In the main function, it initialize some environments, and then initialize the <code>Web Template Framework (WTF)</code> which is a set of commonly used functions from the Webkit codebase by calling the <code>WTF::initialize()</code> function. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jsc.cpp: 2956</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		...</span><br><span class="line">    <span class="comment">// Need to initialize WTF before we start any threads. Cannot initialize JSC</span></span><br><span class="line">    <span class="comment">// yet, since that would do somethings that we&#x27;d like to defer until after we</span></span><br><span class="line">    <span class="comment">// have a chance to parse options.</span></span><br><span class="line">    WTF::<span class="built_in">initialize</span>();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> PLATFORM(COCOA)</span></span><br><span class="line">    WTF::<span class="built_in">disableForwardingVPrintfStdErrToOSLog</span>();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">        res = <span class="built_in">jscmain</span>(argc, argv);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In the <code>jscmain</code> function, it will continue initializing things. In <code>main</code> function, it initialized part of <code>WTF</code> framework,  now it calls <code>WTF::initializeMainThread</code> function to initialize the <code>WTF</code> in more detail. After that, it call <code>mainCommandLine.construct</code> function  to parse the <code>command line</code>. As the comments shows, command options can affect VM creation, for example,  <code>--useConcurrentJIT=false</code> will disable concurrent JIT compile, so it need parse the <code>command line</code> first. Next it initializes the <code>JSC</code> object, and then call <code>runJSC</code> function. Note that the <code>runWithOptions</code> is passed as the forth parameter for the <code>runJSC</code> function.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jsc.cpp: 3699</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jscmain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Need to override and enable restricted options before we start parsing options below.</span></span><br><span class="line">    Config::<span class="built_in">enableRestrictedOptions</span>();</span><br><span class="line"></span><br><span class="line">    WTF::<span class="built_in">initializeMainThread</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note that the options parsing can affect VM creation, and thus</span></span><br><span class="line">    <span class="comment">// comes first.</span></span><br><span class="line">    mainCommandLine.<span class="built_in">construct</span>(argc, argv);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    JSC::<span class="built_in">initialize</span>();</span><br><span class="line">  	...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = <span class="built_in">runJSC</span>(</span><br><span class="line">        mainCommandLine.<span class="built_in">get</span>(), <span class="literal">false</span>,</span><br><span class="line">        [&amp;] (VM&amp; vm, GlobalObject* globalObject, <span class="keyword">bool</span>&amp; success) &#123;</span><br><span class="line">            <span class="built_in">UNUSED_PARAM</span>(vm);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> PLATFORM(COCOA)</span></span><br><span class="line">            vm.<span class="built_in">setOnEachMicrotaskTick</span>(<span class="built_in">WTFMove</span>(onEachMicrotaskTick));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="built_in">runWithOptions</span>(globalObject, mainCommandLine.<span class="built_in">get</span>(), success);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Follow into the <code>runJSC</code> function, it first allocates <code>vm</code> object, and then it will call <code>GlobalObject::create</code> to initialize the <code>vm</code> and <code>globalObject</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jsc.cpp: 3587</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">runJSC</span><span class="params">(<span class="keyword">const</span> CommandLine&amp; options, <span class="keyword">bool</span> isWorker, <span class="keyword">const</span> Func&amp; func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    VM&amp; vm = VM::<span class="built_in">create</span>(LargeHeap).<span class="built_in">leakRef</span>();</span><br><span class="line">    ...</span><br><span class="line">    GlobalObject* globalObject = <span class="literal">nullptr</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        globalObject = GlobalObject::<span class="built_in">create</span>(vm, GlobalObject::<span class="built_in">createStructure</span>(vm, <span class="built_in">jsNull</span>()), options.m_arguments);</span><br><span class="line">        globalObject-&gt;<span class="built_in">setRemoteDebuggingEnabled</span>(options.m_enableRemoteDebugging);</span><br><span class="line">        <span class="built_in">func</span>(vm, globalObject, success);</span><br><span class="line">        vm.<span class="built_in">drainMicrotasks</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>GlobalObject::create</code> is responsible for initialising the <code>VM</code> with the required builtins and other runtime setup activities. The related code is shown as below, it register the <code>runtime builtins</code> such as <code>debug</code> and  <code>describe</code> function by calling <code>addFunction</code>. It inner calls <code>JSGlobalObject::init</code> function, this <code>init</code> function initialize most of <code>js object builtins</code>, such as <code>array</code> and <code>string</code> related <code>builtins</code>. You can follow <code>JSGlobalObject::init</code> function to see how the <code>builtin</code> objects are generated and functions are compiled. I won’t go into that deep here, but i’ll try to explain in another post.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// jsc.cpp: 501</span></span><br><span class="line">		<span class="function"><span class="keyword">static</span> GlobalObject* <span class="title">create</span><span class="params">(VM&amp; vm, Structure* structure, <span class="keyword">const</span> Vector&lt;String&gt;&amp; arguments)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        GlobalObject* object = <span class="built_in"><span class="keyword">new</span></span> (NotNull, allocateCell&lt;GlobalObject&gt;(vm)) <span class="built_in">GlobalObject</span>(vm, structure);</span><br><span class="line">        object-&gt;<span class="built_in">finishCreation</span>(vm, arguments);</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// jsc.cpp: 523</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">finishCreation</span><span class="params">(VM&amp; vm, <span class="keyword">const</span> Vector&lt;String&gt;&amp; arguments)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Base::<span class="built_in">finishCreation</span>(vm);</span><br><span class="line">        <span class="built_in">JSC_TO_STRING_TAG_WITHOUT_TRANSITION</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">addFunction</span>(vm, <span class="string">&quot;debug&quot;</span>, functionDebug, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">addFunction</span>(vm, <span class="string">&quot;describe&quot;</span>, functionDescribe, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">addFunction</span>(vm, <span class="string">&quot;describeArray&quot;</span>, functionDescribeArray, <span class="number">1</span>);</span><br><span class="line">     ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// runtime/JSGlobalObject.cpp: 2622</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">JSGlobalObject::finishCreation</span><span class="params">(VM&amp; vm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">init</span>(vm);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runtime/JSGlobalObject.cpp: 715</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">JSGlobalObject::init</span><span class="params">(VM&amp; vm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    m_functionPrototype-&gt;<span class="built_in">addFunctionProperties</span>(vm, <span class="keyword">this</span>, &amp;callFunction, &amp;applyFunction, &amp;hasInstanceSymbolFunction);</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>After initialize the <code>runtime builtins</code>, <code>runJSC</code> function calls the lambda function(forth parameter), remember the forth parameter is <code>runWithOptions</code> function, so let’s dive into <code>runWithOptions</code> function.</p>
<p>In <code>runWithOptions</code> function, it will get the js file path, and call <code>fetchScriptFromLocalFileSystem</code> to open and read js file content to memory, which will be stored in <code>scriptBuffer</code>. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jsc.cpp: 3153</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runWithOptions</span><span class="params">(GlobalObject* globalObject, CommandLine&amp; options, <span class="keyword">bool</span>&amp; success)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    VM&amp; vm = globalObject-&gt;<span class="built_in">vm</span>();</span><br><span class="line">    <span class="keyword">auto</span> scope = <span class="built_in">DECLARE_CATCH_SCOPE</span>(vm);</span><br><span class="line">  ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; scripts.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (scripts[i].codeSource == Script::CodeSource::File) &#123;</span><br><span class="line">            fileName = scripts[i].argument;</span><br><span class="line">            <span class="keyword">if</span> (scripts[i].strictMode == Script::StrictMode::Strict)</span><br><span class="line">                scriptBuffer.<span class="built_in">append</span>(<span class="string">&quot;\&quot;use strict\&quot;;\n&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;\&quot;use strict\&quot;;\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isModule) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">fetchScriptFromLocalFileSystem</span>(fileName, scriptBuffer)) &#123;</span><br><span class="line">                    success = <span class="literal">false</span>; <span class="comment">// fail early so we can catch missing files</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ...        </span><br><span class="line">        <span class="keyword">bool</span> isLastFile = i == scripts.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        SourceOrigin sourceOrigin &#123; <span class="built_in">absolutePath</span>(fileName) &#125;;</span><br><span class="line">        ...</span><br><span class="line">            JSValue returnValue = <span class="built_in">evaluate</span>(globalObject, <span class="built_in">jscSource</span>(scriptBuffer, sourceOrigin , fileName), <span class="built_in">JSValue</span>(), evaluationException);</span><br><span class="line">            </span><br></pre></td></tr></table></figure>

<p> Before calling <code>evaluate</code> function, <code>runWithOptions</code>  calls <code>jscSource</code> function to build a <code>SouceCode</code> object, the <code>SourceCode</code> object encapsulates the raw script data which is helpful for parsing the source.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jsc.cpp: 1144</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> SourceCode <span class="title">jscSource</span><span class="params">(<span class="keyword">const</span> Vector&amp; utf8, <span class="keyword">const</span> SourceOrigin&amp; sourceOrigin, <span class="keyword">const</span> String&amp; filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span> This should use an absolute file URL https://bugs.webkit.org/show_bug.cgi?id=193077</span></span><br><span class="line">    String str = <span class="built_in">stringFromUTF</span>(utf8);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">jscSource</span>(str, sourceOrigin, filename);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jsc.cpp: 1138</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> SourceCode <span class="title">jscSource</span><span class="params">(<span class="keyword">const</span> String&amp; source, <span class="keyword">const</span> SourceOrigin&amp; sourceOrigin, String sourceURL = String(), <span class="keyword">const</span> TextPosition&amp; startPosition = TextPosition(), SourceProviderSourceType sourceType = SourceProviderSourceType::Program)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">SourceCode</span>(ShellSourceProvider::<span class="built_in">create</span>(source, sourceOrigin, <span class="built_in">WTFMove</span>(sourceURL), startPosition, sourceType), startPosition.m_line.<span class="built_in">oneBasedInt</span>(), startPosition.m_column.<span class="built_in">oneBasedInt</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Right now, the runtime has been set up and the js source has been loaded into memory(<code>source</code>) , <code>runWithOptions</code>  will call <code>evaluate</code> function to interpreter the js, so we can go into the next part.</p>
<h2 id="Parse-to-AST"><a href="#Parse-to-AST" class="headerlink" title="Parse to AST"></a>Parse to AST</h2><p>Now that all the runtime things are ready, we can start to handle the source code, as we can see, the <code>runWithOptions</code> function calls <code>evaluate</code> function to parse and execute js. Follow the <code>evaluate</code> function, we can see it inner calls <code>executeProgram</code> directly.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jsc.cpp: 3153</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runWithOptions</span><span class="params">(GlobalObject* globalObject, CommandLine&amp; options, <span class="keyword">bool</span>&amp; success)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">            JSValue returnValue = <span class="built_in">evaluate</span>(globalObject, <span class="built_in">jscSource</span>(scriptBuffer, sourceOrigin , fileName), <span class="built_in">JSValue</span>(), evaluationException);</span><br><span class="line"></span><br><span class="line"><span class="comment">// runtime/Completion.cpp: 126</span></span><br><span class="line"><span class="function">JSValue <span class="title">evaluate</span><span class="params">(JSGlobalObject* globalObject, <span class="keyword">const</span> SourceCode&amp; source, JSValue thisValue, NakedPtr&lt;Exception&gt;&amp; returnedException)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!thisValue || thisValue.<span class="built_in">isUndefinedOrNull</span>())</span><br><span class="line">        thisValue = globalObject;</span><br><span class="line">    JSObject* thisObj = jsCast&lt;JSObject*&gt;(thisValue.<span class="built_in">toThis</span>(globalObject, ECMAMode::<span class="built_in">sloppy</span>()));</span><br><span class="line">    JSValue result = vm.interpreter-&gt;<span class="built_in">executeProgram</span>(source, globalObject, thisObj);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Get into <code>executeProgram</code> function, it responsible for parsing and executing the js source, which can be concluded as 6 parts: </p>
<ol>
<li><code>ProgramExecutable::create</code> to allocate <code>ProgramExecutable</code> object, which inner allocate some important object.</li>
<li>check it’s <code>JSON </code> source code or not, if it is, parse as json, for we don’t care about that part, just ignore it.</li>
<li>call  <code>program-&gt;initializeGlobalProperties</code>  to compile the js source to <code>unlinked</code> bytecode.</li>
<li>call <code>program-&gt;prepareForExecution</code> to link the <code>unlinked</code> bytecode to <code>linked</code> bytecode.</li>
<li>call <code>protoCallFrame.init</code> to set up the entry pointer for <code>interpreter</code>.</li>
<li>call <code>jitCode-&gt;execute</code> to interpreter the <code>bytecode</code>.</li>
</ol>
<p>In this section we care about the first 3 steps, i’ll explain it in detail here.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interpreter/Interpreter.cpp: 709</span></span><br><span class="line"><span class="function">JSValue <span class="title">Interpreter::executeProgram</span><span class="params">(<span class="keyword">const</span> SourceCode&amp; source, JSGlobalObject*, JSObject* thisObj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ProgramExecutable* program = ProgramExecutable::<span class="built_in">create</span>(globalObject, source);</span><br><span class="line">  </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// First check if the &quot;program&quot; is actually just a JSON object. If so,</span></span><br><span class="line">    <span class="comment">// we&#x27;ll handle the JSON object here. Else, we&#x27;ll handle real JS code</span></span><br><span class="line">    <span class="comment">// below at failedJSONP.</span></span><br><span class="line"></span><br><span class="line">    Vector&lt;JSONPData&gt; JSONPData;</span><br><span class="line">    <span class="keyword">bool</span> parseResult;</span><br><span class="line">    StringView programSource = program-&gt;<span class="built_in">source</span>().<span class="built_in">view</span>();</span><br><span class="line">    <span class="keyword">if</span> (programSource.<span class="built_in">isNull</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">jsUndefined</span>();</span><br><span class="line">    <span class="keyword">if</span> (programSource.<span class="built_in">is8Bit</span>()) &#123;</span><br><span class="line">        <span class="function">LiteralParser&lt;LChar&gt; <span class="title">literalParser</span><span class="params">(globalObject, programSource.characters8(), programSource.length(), JSONP)</span></span>;</span><br><span class="line">        parseResult = literalParser.<span class="built_in">tryJSONPParse</span>(JSONPData, globalObject-&gt;<span class="built_in">globalObjectMethodTable</span>()-&gt;<span class="built_in">supportsRichSourceInfo</span>(globalObject));</span><br><span class="line">    &#125; ...</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RETURN_IF_EXCEPTION</span>(throwScope, &#123; &#125;);</span><br><span class="line">    <span class="keyword">if</span> (parseResult) &#123;</span><br><span class="line">        ...</span><br><span class="line">failedJSONP:</span><br><span class="line">    <span class="comment">// If we get here, then we have already proven that the script is not a JSON</span></span><br><span class="line">    <span class="comment">// object.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compile source to bytecode if necessary:</span></span><br><span class="line">    JSObject* error = program-&gt;<span class="built_in">initializeGlobalProperties</span>(vm, globalObject, scope);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    ProgramCodeBlock* codeBlock;</span><br><span class="line">    &#123;</span><br><span class="line">        CodeBlock* tempCodeBlock;</span><br><span class="line">        program-&gt;prepareForExecution&lt;ProgramExecutable&gt;(vm, <span class="literal">nullptr</span>, scope, CodeForCall, tempCodeBlock);</span><br><span class="line">        <span class="built_in">RETURN_IF_EXCEPTION</span>(throwScope, <span class="built_in">checkedReturn</span>(throwScope.<span class="built_in">exception</span>()));</span><br><span class="line"></span><br><span class="line">        codeBlock = jsCast&lt;ProgramCodeBlock*&gt;(tempCodeBlock);</span><br><span class="line">        <span class="built_in">ASSERT</span>(codeBlock &amp;&amp; codeBlock-&gt;<span class="built_in">numParameters</span>() == <span class="number">1</span>); <span class="comment">// 1 parameter for &#x27;this&#x27;.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RefPtr&lt;JITCode&gt; jitCode;</span><br><span class="line">    ProtoCallFrame protoCallFrame;</span><br><span class="line">    &#123;</span><br><span class="line">        DisallowGC disallowGC; <span class="comment">// Ensure no GC happens. GC can replace CodeBlock in Executable.</span></span><br><span class="line">        jitCode = program-&gt;<span class="built_in">generatedJITCode</span>();</span><br><span class="line">        protoCallFrame.<span class="built_in">init</span>(codeBlock, globalObject, globalCallee, thisObj, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute the code:</span></span><br><span class="line">    throwScope.<span class="built_in">release</span>();</span><br><span class="line">    <span class="built_in">ASSERT</span>(jitCode == program-&gt;<span class="built_in">generatedJITCode</span>().<span class="built_in">ptr</span>());</span><br><span class="line">    JSValue result = jitCode-&gt;<span class="built_in">execute</span>(&amp;vm, &amp;protoCallFrame);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">checkedReturn</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>Interpreter::executeProgram</code> first call <code>ProgramExecutable::create</code> to allocate a <code>ProgramExecutable</code> object. In <code>ProgramExecutable</code>‘s constructor, it will initialize its base class which is <code>GlobalExecutable</code> object. In <code>GlobalExecutable</code> object’s constructor, it will initialize its base class which is <code>ScriptExecutable</code> object, which will finally initialize <code>ExecutableBase</code> object. All the upper objects are important in the running process, some objects are also useful for exploiting, we should keep in mind here.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// runtime/ProgramExecutable.h: 45</span></span><br><span class="line">		<span class="function"><span class="keyword">static</span> ProgramExecutable* <span class="title">create</span><span class="params">(JSGlobalObject* globalObject, <span class="keyword">const</span> SourceCode&amp; source)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        VM&amp; vm = <span class="built_in">getVM</span>(globalObject);</span><br><span class="line">        ProgramExecutable* executable = <span class="built_in"><span class="keyword">new</span></span> (NotNull, allocateCell&lt;ProgramExecutable&gt;(vm)) <span class="built_in">ProgramExecutable</span>(globalObject, source);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> executable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runtime/ProgramExecutable.cpp: 37</span></span><br><span class="line">ProgramExecutable::<span class="built_in">ProgramExecutable</span>(JSGlobalObject* globalObject, <span class="keyword">const</span> SourceCode&amp; source)</span><br><span class="line">    : <span class="built_in">Base</span>(globalObject-&gt;<span class="built_in">vm</span>().programExecutableStructure.<span class="built_in">get</span>(), globalObject-&gt;<span class="built_in">vm</span>(), source, <span class="literal">false</span>, DerivedContextType::None, <span class="literal">false</span>, <span class="literal">false</span>, EvalContextType::None, NoIntrinsic)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runtime/GlobalExecutable.h: 52</span></span><br><span class="line">    <span class="built_in">GlobalExecutable</span>(Structure* structure, VM&amp; vm, <span class="keyword">const</span> SourceCode&amp; sourceCode, <span class="keyword">bool</span> isInStrictContext, DerivedContextType derivedContextType, <span class="keyword">bool</span> isInArrowFunctionContext, <span class="keyword">bool</span> isInsideOrdinaryFunction, EvalContextType evalContextType, Intrinsic intrinsic)</span><br><span class="line">        : <span class="built_in">Base</span>(structure, vm, sourceCode, isInStrictContext ? StrictModeLexicalFeature : NoLexicalFeatures, derivedContextType, isInArrowFunctionContext, isInsideOrdinaryFunction, evalContextType, intrinsic)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runtime/ScriptExecutable.cpp: 49</span></span><br><span class="line">ScriptExecutable::<span class="built_in">ScriptExecutable</span>(Structure* structure, VM&amp; vm, <span class="keyword">const</span> SourceCode&amp; source, LexicalScopeFeatures lexicalScopeFeatures, DerivedContextType derivedContextType, <span class="keyword">bool</span> isInArrowFunctionContext, <span class="keyword">bool</span> isInsideOrdinaryFunction, EvalContextType evalContextType, Intrinsic intrinsic)</span><br><span class="line">    : <span class="built_in">ExecutableBase</span>(vm, structure)</span><br><span class="line">    , <span class="built_in">m_source</span>(source)</span><br><span class="line">    , <span class="built_in">m_intrinsic</span>(intrinsic)</span><br><span class="line">    , <span class="built_in">m_features</span>(NoFeatures)</span><br><span class="line">    , <span class="built_in">m_lexicalScopeFeatures</span>(lexicalScopeFeatures)</span><br><span class="line">    , <span class="built_in">m_hasCapturedVariables</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">m_neverInline</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">m_neverOptimize</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">m_neverFTLOptimize</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">m_isArrowFunctionContext</span>(isInArrowFunctionContext)</span><br><span class="line">    , <span class="built_in">m_canUseOSRExitFuzzing</span>(<span class="literal">true</span>)</span><br><span class="line">    , <span class="built_in">m_codeForGeneratorBodyWasGenerated</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">m_isInsideOrdinaryFunction</span>(isInsideOrdinaryFunction)</span><br><span class="line">    , <span class="built_in">m_derivedContextType</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span>&gt;(derivedContextType))</span><br><span class="line">    , <span class="built_in">m_evalContextType</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span>&gt;(evalContextType))</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>After allocating the related objects, <code>Interpreter::executeProgram</code> checks the source code whether is json format or not, as we said before, we don’t care about that, so i’ll skip this part of code.</p>
<p>And then as the comment shows, <code>Interpreter::executeProgram</code> function calls <code>program-&gt;initializeGlobalProperties</code>  to compile source to <code>unlinked</code> bytecode. What we focus on in this part is that how to parse the source to <code>AST</code>, so we have arrived the key point in this section which is the <code>initializeGlobalProperties</code> function.</p>
<p>Let’s check the <code>initializeGlobalProperties</code> function, it calls <code>getUnlinkedProgramCodeBlock</code> function to generate <code>UnlinkedProgramCodeBlock</code> which is used to store <code>unlinked</code> bytecode, and then do some additional checks, we just take care about <code>getUnlinkedProgramCodeBlock</code> function here.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/ProgramExecutable.cpp: 67</span></span><br><span class="line"><span class="function">JSObject* <span class="title">ProgramExecutable::initializeGlobalProperties</span><span class="params">(VM&amp; vm, JSGlobalObject* globalObject, JSScope* scope)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode = globalObject-&gt;<span class="built_in">defaultCodeGenerationMode</span>();</span><br><span class="line">    UnlinkedProgramCodeBlock* unlinkedCodeBlock = vm.<span class="built_in">codeCache</span>()-&gt;<span class="built_in">getUnlinkedProgramCodeBlock</span>(</span><br><span class="line">        vm, <span class="keyword">this</span>, <span class="built_in">source</span>(), strictMode, codeGenerationMode, error);</span><br><span class="line">  ...</span><br><span class="line">  &#123;</span><br><span class="line">        <span class="comment">// Check for intersection of &quot;var&quot; and &quot;let&quot;/&quot;const&quot;/&quot;class&quot;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; entry : lexicalDeclarations) &#123;</span><br><span class="line">            <span class="keyword">if</span> (variableDeclarations.<span class="built_in">contains</span>(entry.key))</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">createSyntaxError</span>(globalObject, <span class="built_in">makeString</span>(<span class="string">&quot;Can&#x27;t create duplicate variable: &#x27;&quot;</span>, <span class="built_in">String</span>(entry.key.<span class="built_in">get</span>()), <span class="string">&quot;&#x27;&quot;</span>));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>Follow the code execution flow, we can see it forms the below call stack chain <code>CodeCache::getUnlinkedProgramCodeBlock-&gt;CodeCache::getUnlinkedGlobalCodeBlock-&gt;generateUnlinkedCodeBlock-&gt;generateUnlinkedCodeBlock-&gt;generateUnlinkedCodeBlockImpl</code>. The last function <code>generateUnlinkedCodeBlockImpl</code> is the final function which is responsible for generating the <code>unlinked</code> bytecode.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/CodeCache.cpp: 189</span></span><br><span class="line"><span class="function">UnlinkedProgramCodeBlock* <span class="title">CodeCache::getUnlinkedProgramCodeBlock</span><span class="params">(VM&amp; vm, ProgramExecutable* executable, <span class="keyword">const</span> SourceCode&amp; source, JSParserStrictMode strictMode, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, ParserError&amp; error)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getUnlinkedGlobalCodeBlock&lt;UnlinkedProgramCodeBlock&gt;(vm, executable, source, strictMode, JSParserScriptMode::Classic, codeGenerationMode, error, EvalContextType::None);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"> <span class="comment">// runtime/CodeCache.cpp: 154</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">UnlinkedCodeBlockType</span>, <span class="keyword">class</span> <span class="title">ExecutableType</span>&gt;</span></span><br><span class="line"><span class="function">UnlinkedCodeBlockType* <span class="title">CodeCache::getUnlinkedGlobalCodeBlock</span><span class="params">(VM&amp; vm, ExecutableType* executable, <span class="keyword">const</span> SourceCode&amp; source, JSParserStrictMode strictMode, JSParserScriptMode scriptMode, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, ParserError&amp; error, EvalContextType evalContextType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    unlinkedCodeBlock = generateUnlinkedCodeBlock&lt;UnlinkedCodeBlockType, ExecutableType&gt;(vm, executable, source, strictMode, scriptMode, codeGenerationMode, error, evalContextType);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> unlinkedCodeBlock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runtime/CodeCache.cpp: 119</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">UnlinkedCodeBlockType</span>, <span class="keyword">class</span> <span class="title">ExecutableType</span>&gt;</span></span><br><span class="line"><span class="function">UnlinkedCodeBlockType* <span class="title">generateUnlinkedCodeBlock</span><span class="params">(VM&amp; vm, ExecutableType* executable, <span class="keyword">const</span> SourceCode&amp; source, JSParserStrictMode strictMode, JSParserScriptMode scriptMode, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, ParserError&amp; error, EvalContextType evalContextType, <span class="keyword">const</span> TDZEnvironment* variablesUnderTDZ = <span class="literal">nullptr</span>, <span class="keyword">const</span> PrivateNameEnvironment* privateNameEnvironment = <span class="literal">nullptr</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> generateUnlinkedCodeBlockImpl&lt;UnlinkedCodeBlockType, ExecutableType&gt;(vm, source, strictMode, scriptMode, codeGenerationMode, error, evalContextType, executable-&gt;<span class="built_in">derivedContextType</span>(), executable-&gt;<span class="built_in">isArrowFunctionContext</span>(), variablesUnderTDZ, privateNameEnvironment, executable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The call <code>stack</code> in gdb is shown as below:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bt</span><br><span class="line">#0  JSC::generateUnlinkedCodeBlockImpl&lt;JSC::UnlinkedProgramCodeBlock, JSC::ProgramExecutable&gt; (vm=..., source=..., strictMode=JSC::JSParserStrictMode::NotStrict, scriptMode=JSC::JSParserScriptMode::Classic, codeGenerationMode=..., error=..., evalContextType=JSC::EvalContextType::None, derivedContextType=JSC::DerivedContextType::None, isArrowFunctionContext=0x0, variablesUnderTDZ=0x0, privateNameEnvironment=0x0, executable=0x7ffff17fa848) at ../../Source/JavaScriptCore/runtime/CodeCache.cpp:77</span><br><span class="line">#1  0x00007ffff5d037c1 in JSC::generateUnlinkedCodeBlock&lt;JSC::UnlinkedProgramCodeBlock, JSC::ProgramExecutable&gt; (vm=..., executable=0x7ffff17fa848, source=..., strictMode=JSC::JSParserStrictMode::NotStrict, scriptMode=JSC::JSParserScriptMode::Classic, codeGenerationMode=..., error=..., evalContextType=JSC::EvalContextType::None, variablesUnderTDZ=0x0, privateNameEnvironment=0x0) at ../../Source/JavaScriptCore/runtime/CodeCache.cpp:122</span><br><span class="line">#2  0x00007ffff5cf66d4 in JSC::CodeCache::getUnlinkedGlobalCodeBlock&lt;JSC::UnlinkedProgramCodeBlock, JSC::ProgramExecutable&gt; (this=0x7ffff17e70d8, vm=..., executable=0x7ffff17fa848, source=..., strictMode=JSC::JSParserStrictMode::NotStrict, scriptMode=JSC::JSParserScriptMode::Classic, codeGenerationMode=..., error=..., evalContextType=JSC::EvalContextType::None) at ../../Source/JavaScriptCore/runtime/CodeCache.cpp:176</span><br><span class="line">#3  0x00007ffff5ce2c38 in JSC::CodeCache::getUnlinkedProgramCodeBlock (this=0x7ffff17e70d8, vm=..., executable=0x7ffff17fa848, source=..., strictMode=JSC::JSParserStrictMode::NotStrict, codeGenerationMode=..., error=...) at ../../Source/JavaScriptCore/runtime/CodeCache.cpp:191</span><br><span class="line">#4  0x00007ffff601c50a in JSC::ProgramExecutable::initializeGlobalProperties (this=0x7ffff17fa848, vm=..., globalObject=0x7fffb11f6068, scope=0x7ffff17b7068) at ../../Source/JavaScriptCore/runtime/ProgramExecutable.cpp:79</span><br><span class="line">#5  0x00007ffff5996d1a in JSC::Interpreter::executeProgram (this=0x7ffff17fe248, source=..., thisObj=0x7ffff17ac608) at ../../Source/JavaScriptCore/interpreter/Interpreter.cpp:864</span><br><span class="line">#6  0x00007ffff5d3e625 in JSC::evaluate (globalObject=0x7fffb11f6068, source=..., thisValue=..., returnedException=...) at ../../Source/JavaScriptCore/runtime/Completion.cpp:137</span><br><span class="line">#7  0x0000555555579d72 in runWithOptions (globalObject=0x7fffb11f6068, options=..., success=@0x7fffffffdf82: 0x1) at ../../Source/JavaScriptCore/jsc.cpp:3216</span><br><span class="line">#8  0x000055555557b40c in &lt;lambda(JSC::VM&amp;, GlobalObject*, bool&amp;)&gt;::operator()(JSC::VM &amp;, GlobalObject *, bool &amp;) const (__closure=0x7fffffffe100, vm=..., globalObject=0x7fffb11f6068, success=@0x7fffffffdf82: 0x1) at ../../Source/JavaScriptCore/jsc.cpp:3785</span><br><span class="line">#9  0x000055555557d780 in runJSC&lt;jscmain(int, char**)::&lt;lambda(JSC::VM&amp;, GlobalObject*, bool&amp;)&gt; &gt;(const CommandLine &amp;, bool, const &lt;lambda(JSC::VM&amp;, GlobalObject*, bool&amp;)&gt; &amp;) (options=..., isWorker=0x0, func=...) at ../../Source/JavaScriptCore/jsc.cpp:3607</span><br><span class="line">#10 0x000055555557b559 in jscmain (argc=0x3, argv=0x7fffffffe248) at ../../Source/JavaScriptCore/jsc.cpp:3778</span><br><span class="line">#11 0x000055555557849a in main (argc=0x3, argv=0x7fffffffe248) at ../../Source/JavaScriptCore/jsc.cpp:3004</span><br><span class="line">#12 0x00007ffff40940b3 in __libc_start_main (main=0x55555557846a &lt;main(int, char**)&gt;, argc=0x3, argv=0x7fffffffe248, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffe238) at ../csu/libc-start.c:308</span><br><span class="line">#13 0x00005555555649be in _start ()</span><br></pre></td></tr></table></figure>

<p>Now we get into <code>generateUnlinkedCodeBlockImpl</code>, this function can be devided into two part:</p>
<ul>
<li>the first part is <code>parse&lt;RootNode&gt;</code>, which is responsible for lexing and parsing the souce code to <code>AST</code>.</li>
<li>the second part is <code>BytecodeGenerator::generate</code>, which is responsible for generating the <code>unlinked</code> bytecode from <code>AST</code>.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/CodeCache.cpp: 73</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">UnlinkedCodeBlockType</span>, <span class="keyword">class</span> <span class="title">ExecutableType</span> =</span> ScriptExecutable&gt;</span><br><span class="line"><span class="function">UnlinkedCodeBlockType* <span class="title">generateUnlinkedCodeBlockImpl</span><span class="params">(VM&amp; vm, <span class="keyword">const</span> SourceCode&amp; source, JSParserStrictMode </span></span></span><br><span class="line"><span class="params"><span class="function">...</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    ...</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">    std::unique_ptr&lt;RootNode&gt; rootNode = parse&lt;RootNode&gt;(</span></span></span><br><span class="line"><span class="params"><span class="function">        vm, source, Identifier(), JSParserBuiltinMode::NotBuiltin, strictMode, scriptMode, CacheTypes&lt;UnlinkedCodeBlockType&gt;::parseMode, SuperBinding::NotNeeded, error, <span class="literal">nullptr</span>, ConstructorKind::None, derivedContextType, evalContextType, <span class="literal">nullptr</span>, privateNameEnvironment, <span class="literal">nullptr</span>, isInsideOrdinaryFunction);</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">if</span> (!rootNode)</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">    ...</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">    UnlinkedCodeBlockType* unlinkedCodeBlock = UnlinkedCodeBlockType::create(vm, executableInfo, codeGenerationMode);</span></span></span><br><span class="line"><span class="params"><span class="function">    ...</span></span></span><br><span class="line"><span class="params"><span class="function">    error = BytecodeGenerator::generate(vm, rootNode.get(), source, unlinkedCodeBlock, codeGenerationMode, parentVariablesUnderTDZ, privateNameEnvironment);</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">if</span> (error.isValid())</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">return</span> unlinkedCodeBlock;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br></pre></td></tr></table></figure>

<p>In this section we focus on the first part which is the <code>parse</code> function, just check out this function.</p>
<p>In the <code>parse</code> function, it first calls <code>Parser</code> constructor to initialize a <code>parser</code> and then calls <code>parser.parse</code> function to <code>lex</code> and <code>parse</code> the source code to <code>AST</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parser/Parser.h: 2191</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ParsedNode</span>&gt;</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;ParsedNode&gt; <span class="title">parse</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ...</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">    std::unique_ptr&lt;ParsedNode&gt; result;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">if</span> (source.provider()-&gt;source().is8Bit()) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        Parser&lt;Lexer&lt;LChar&gt;&gt; parser(vm, source, builtinMode, strictMode, scriptMode, parseMode, superBinding, defaultConstructorKindForTopLevelFunction, derivedContextType, isEvalNode&lt;ParsedNode&gt;(), evalContextType, debuggerParseData, isInsideOrdinaryFunction);</span></span></span><br><span class="line"><span class="params"><span class="function">        result = parser.parse&lt;ParsedNode&gt;(error, name, isEvalNode&lt;ParsedNode&gt;() ? ParsingContext::Eval : ParsingContext::Program, std::nullopt, parentScopePrivateNames, classFieldLocations);</span></span></span><br><span class="line"><span class="params"><span class="function">        ...</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125; <span class="keyword">else</span> &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        ...</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">return</span> result;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br></pre></td></tr></table></figure>

<p>So first let’s go to see how the <code>parser</code> is initialized, it initializes a <code>m_lexer</code> which is used to <code>lex</code> the source code. It also initializes a <code>m_token</code> which is used to store the token that the <code>m_lexer</code> lexed out.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parser/Parser.cpp: 130</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> LexerType&gt;</span><br><span class="line">Parser&lt;LexerType&gt;::<span class="built_in">Parser</span>(VM&amp; vm, <span class="keyword">const</span> SourceCode&amp; source, JSParserBuiltinMode builtinMode, </span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">    m_lexer = makeUnique&lt;LexerType&gt;(vm, builtinMode, scriptMode);</span><br><span class="line">    m_lexer-&gt;<span class="built_in">setCode</span>(source, &amp;m_parserArena);</span><br><span class="line">    m_token.m_location.line = source.<span class="built_in">firstLine</span>().<span class="built_in">oneBasedInt</span>();</span><br><span class="line">    m_token.m_location.startOffset = source.<span class="built_in">startOffset</span>();</span><br><span class="line">    m_token.m_location.endOffset = source.<span class="built_in">startOffset</span>();</span><br><span class="line">    m_token.m_location.lineStartOffset = source.<span class="built_in">startOffset</span>();</span><br><span class="line">    m_functionCache = vm.<span class="built_in">addSourceProviderCache</span>(source.<span class="built_in">provider</span>());</span><br><span class="line">    m_expressionErrorClassifier = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="built_in">next</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Then it calls the <code>next</code> function to <code>lex</code> the first token out from the source code. <code>next</code> function can be said to be a key function in lexing. It takes the source as input and lex a <code>m_token</code> out. Get into the <code>next</code> function, we can see it calls <code>m_lexer-&gt;lex</code> to lex the <code>source</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// parser/Parser.h: 1490</span></span><br><span class="line"><span class="function">ALWAYS_INLINE <span class="keyword">void</span> <span class="title">next</span><span class="params">(OptionSet&lt;LexerFlags&gt; lexerFlags = &#123; &#125;)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> lastLine = m_token.m_location.line;</span><br><span class="line">      <span class="keyword">int</span> lastTokenEnd = m_token.m_location.endOffset;</span><br><span class="line">      <span class="keyword">int</span> lastTokenLineStart = m_token.m_location.lineStartOffset;</span><br><span class="line">      m_lastTokenEndPosition = <span class="built_in">JSTextPosition</span>(lastLine, lastTokenEnd, lastTokenLineStart);</span><br><span class="line">      m_lexer-&gt;<span class="built_in">setLastLineNumber</span>(lastLine);</span><br><span class="line">      m_token.m_type = m_lexer-&gt;<span class="built_in">lex</span>(&amp;m_token, lexerFlags, <span class="built_in">strictMode</span>());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>Follow into the <code>lex</code> function, it directly calls <code>lexWithoutClearingLineTerminator</code> function.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parser/Lexer.h: 409</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ALWAYS_INLINE JSTokenType Lexer&lt;T&gt;::<span class="built_in">lex</span>(JSToken* tokenRecord, OptionSet&lt;LexerFlags&gt; lexerFlags, <span class="keyword">bool</span> strictMode)</span><br><span class="line">&#123;</span><br><span class="line">    m_hasLineTerminatorBeforeToken = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lexWithoutClearingLineTerminator</span>(tokenRecord, lexerFlags, strictMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dive into <code>lexWithoutClearingLineTerminator</code> function, it will call <code>skipWhitespace</code> to  skip the white space, and get the type according to the <code>m_current</code>, which is the character that being parsed, and then lex the word out according to the type.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parser/Lexer.cpp: 1907</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">JSTokenType Lexer&lt;T&gt;::<span class="built_in">lexWithoutClearingLineTerminator</span>(JSToken* tokenRecord, OptionSet&lt;LexerFlags&gt; lexerFlags, <span class="keyword">bool</span> strictMode)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">    <span class="built_in">skipWhitespace</span>();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    CharacterType type;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">LIKELY</span>(<span class="built_in">isLatin1</span>(m_current)))</span><br><span class="line">        type = <span class="keyword">static_cast</span>&lt;CharacterType&gt;(typesOfLatin1Characters[m_current]);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        UChar32 codePoint;</span><br><span class="line">        <span class="built_in">U16_GET</span>(m_code, <span class="number">0</span>, <span class="number">0</span>, m_codeEnd - m_code, codePoint);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isNonLatin1IdentStart</span>(codePoint))</span><br><span class="line">            type = CharacterIdentifierStart;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isLineTerminator</span>(m_current))</span><br><span class="line">            type = CharacterLineTerminator;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            type = CharacterInvalid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> CharacterGreater:</span><br><span class="line">        <span class="built_in">shift</span>();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> CharacterGreater:</span><br><span class="line">        <span class="built_in">shift</span>();</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> CharacterEqual: </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> CharacterLess:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> CharacterExclamationMark:</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// parser/Lexer.cpp: 2489</span></span><br><span class="line">    <span class="keyword">case</span> CharacterIdentifierStart: &#123;</span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(ASSERT_ENABLED)</span> </span>&#123;</span><br><span class="line">            UChar32 codePoint;</span><br><span class="line">            <span class="built_in">U16_GET</span>(m_code, <span class="number">0</span>, <span class="number">0</span>, m_codeEnd - m_code, codePoint);</span><br><span class="line">            <span class="built_in">ASSERT</span>(<span class="built_in">isIdentStart</span>(codePoint));</span><br><span class="line">        &#125;</span><br><span class="line">        FALLTHROUGH;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> CharacterBackSlash:</span><br><span class="line">        parseIdent:</span><br><span class="line">        <span class="keyword">if</span> (lexerFlags.<span class="built_in">contains</span>(LexerFlags::DontBuildKeywords))</span><br><span class="line">            token = parseIdentifier&lt;<span class="literal">false</span>&gt;(tokenData, lexerFlags, strictMode);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            token = parseIdentifier&lt;<span class="literal">true</span>&gt;(tokenData, lexerFlags, strictMode);</span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>Take the <code>demo.js</code>‘s first line <code>let x = 10</code> as a example, when the <code>m_current</code> is <code>l</code>, the type is <code>CharacterIdentifierStart</code>, and it will call <code>parseIdentifier</code> to parse a <code>identifier</code>. <code>parseIdentifier</code> first calls <code>parseKeyword</code> function to get the <code>keyword</code> out, as we can see, the <code>let</code> is mapped to <code>LET</code> keyword. Now we finished the lex of first word <code>let</code> and understand the mechanism of <code>next</code> function.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parser/Lexer.cpp: 936</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> shouldCreateIdentifier&gt; ALWAYS_INLINE JSTokenType Lexer&lt;LChar&gt;::<span class="built_in">parseIdentifier</span>(JSTokenData* tokenData, OptionSet&lt;LexerFlags&gt; lexerFlags, <span class="keyword">bool</span> strictMode)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> ((remaining &gt;= maxTokenLength) &amp;&amp; !lexerFlags.<span class="built_in">contains</span>(LexerFlags::IgnoreReservedWords)) &#123;</span><br><span class="line">        JSTokenType keyword = parseKeyword&lt;shouldCreateIdentifier&gt;(tokenData);</span><br><span class="line">        <span class="keyword">if</span> (keyword != IDENT) &#123;</span><br><span class="line">            <span class="built_in">ASSERT</span>((!shouldCreateIdentifier) || tokenData-&gt;ident);</span><br><span class="line">            <span class="keyword">return</span> keyword == RESERVED_IF_STRICT &amp;&amp; !strictMode ? IDENT : keyword;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">// JavaScriptCore/KerywordLookup.h: 462</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> shouldCreateIdentifier&gt; ALWAYS_INLINE JSTokenType Lexer&lt;LChar&gt;::<span class="built_in">parseKeyword</span>(JSTokenData* data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">ASSERT</span>(m_codeEnd - m_code &gt;= maxTokenLength);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> LChar* code = m_code;</span><br><span class="line">    <span class="keyword">if</span> (code[<span class="number">0</span>] == <span class="string">&#x27;f&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">COMPARE_7CHARS</span>(code + <span class="number">1</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;n&#x27;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">LIKELY</span>(<span class="built_in">cannotBeIdentPartOrEscapeStart</span>(code[<span class="number">8</span>]))) &#123;</span><br><span class="line">                internalShift&lt;<span class="number">8</span>&gt;();</span><br><span class="line">                <span class="keyword">if</span> (shouldCreateIdentifier)</span><br><span class="line">                    data-&gt;ident = &amp;m_vm.propertyNames-&gt;functionKeyword;</span><br><span class="line">                <span class="keyword">return</span> FUNCTION;</span><br><span class="line">            &#125;</span><br><span class="line">     ...    </span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">COMPARE_3CHARS</span>(code, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;t&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">LIKELY</span>(<span class="built_in">cannotBeIdentPartOrEscapeStart</span>(code[<span class="number">3</span>]))) &#123;</span><br><span class="line">            internalShift&lt;<span class="number">3</span>&gt;();</span><br><span class="line">            <span class="keyword">if</span> (shouldCreateIdentifier)</span><br><span class="line">                data-&gt;ident = &amp;m_vm.propertyNames-&gt;letKeyword;</span><br><span class="line">            <span class="keyword">return</span> LET;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>So we finished the initialization of <code>parser</code>, we can go back the <code>parse</code> function and see how to build the <code>AST</code> in  <code>parser.parse</code> function.</p>
<p>Get into the <code>parser.parse</code> function, we can see it inner calls <code>parseInner</code> function to parse the source.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parser/Parser.h: 2100</span></span><br><span class="line">std::unique_ptr&lt;ParsedNode&gt; Parser&lt;LexerType&gt;::<span class="built_in">parse</span>(ParserError&amp; error, <span class="keyword">const</span> Identifier&amp; calleeName, ParsingContext parsingContext, std::optional&lt;<span class="keyword">int</span>&gt; functionConstructorParametersEndPosition, <span class="keyword">const</span> PrivateNameEnvironment* parentScopePrivateNames, <span class="keyword">const</span> FixedVector&lt;JSTextPosition&gt;* classFieldLocations)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">auto</span> parseResult = <span class="built_in">parseInner</span>(calleeName, parsingContext, functionConstructorParametersEndPosition, classFieldLocations, parentScopePrivateNames);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In the <code>parseInner</code> function, it first build a <code>context</code> object to store the <code>AST</code> result, which is a <code>ASTBuilder</code> class. And then because the <code>demo</code>  is not a function, just a program, so <code>parseInner</code> invokes <code>parseSourceElements</code> to generate the <code>AST</code>, after finishing the generation of the <code>AST</code>, it will also perform some additional check for the <code>AST</code>, and finally return the parse result.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parser/Parser.cpp: 223</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> LexerType&gt;</span><br><span class="line">Expected&lt;<span class="keyword">typename</span> Parser&lt;LexerType&gt;::ParseInnerResult, String&gt; Parser&lt;LexerType&gt;::<span class="built_in">parseInner</span>(<span class="keyword">const</span> Identifier&amp; calleeName, ParsingContext parsingContext, std::optional&lt;<span class="keyword">int</span>&gt; functionConstructorParametersEndPosition, <span class="keyword">const</span> FixedVector&lt;JSTextPosition&gt;* classFieldLocations, <span class="keyword">const</span> PrivateNameEnvironment* parentScopePrivateNames)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">ASTBuilder <span class="title">context</span><span class="params">(<span class="keyword">const_cast</span>&lt;VM&amp;&gt;(m_vm), m_parserArena, <span class="keyword">const_cast</span>&lt;SourceCode*&gt;(m_source))</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// The only way we can error this early is if we reparse a function and we run out of stack space.</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">hasError</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isAsyncFunctionWrapperParseMode</span>(parseMode))</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            sourceElements = <span class="built_in">parseSourceElements</span>(context, CheckForStrictMode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> validEnding = <span class="built_in">consume</span>(EOFTOK);</span><br><span class="line">    <span class="keyword">if</span> (!sourceElements || !validEnding)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">makeUnexpected</span>(<span class="built_in">hasError</span>() ? m_errorMessage : <span class="string">&quot;Parser error&quot;</span>_s);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ParseInnerResult &#123; parameters, sourceElements, scope-&gt;<span class="built_in">takeFunctionDeclarations</span>(), scope-&gt;<span class="built_in">takeDeclaredVariables</span>(), scope-&gt;<span class="built_in">takeLexicalEnvironment</span>(), <span class="built_in">WTFMove</span>(sloppyModeHoistedFunctions), features, context.<span class="built_in">numConstants</span>() &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>So we need get into <code>parseSourceElements</code> function to see how it build the <code>AST</code> tree. The <code>context</code> first calls <code>createSourceElements</code>  function to allocate a <code>sourceElements</code> object, and then call <code>parseStatementListItem</code> function to parse the source. The  <code>parseStatementListItem</code> takes the source as input, and output the next <code>AST</code> node, the <code>AST</code> node is named as <code>statement</code>  in <code>jsc</code>. Once the <code>statement</code> has been generated, it will be appended into the <code>sourceElements</code>, which eventually forms the <code>AST</code> tree.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parser/Parser.cpp: 401</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> LexerType&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">TreeBuilder</span>&gt;</span> TreeSourceElements Parser&lt;LexerType&gt;::<span class="built_in">parseSourceElements</span>(TreeBuilder&amp; context, SourceElementsMode mode)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    TreeSourceElements sourceElements = context.<span class="built_in">createSourceElements</span>();</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (TreeStatement statement = <span class="built_in">parseStatementListItem</span>(context, directive, &amp;directiveLiteralLength)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (shouldCheckForUseStrict) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        context.<span class="built_in">appendStatement</span>(sourceElements, statement);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">propagateError</span>();</span><br><span class="line">    <span class="keyword">return</span> sourceElements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The function <code>parseStatementListItem</code> is responsible for parsing the source code to construct a <code>statement</code>.</p>
<p>In <code>parseStatementListItem</code> function, it will perform the corresponding parse and generate the <code>statement</code> according to the <code>m_token.m_type</code>, which is the <code>key</code> word that the <code>next</code> function returns. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parser/Parser.cpp: 700</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> LexerType&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">TreeBuilder</span>&gt;</span> TreeStatement Parser&lt;LexerType&gt;::<span class="built_in">parseStatementListItem</span>(TreeBuilder&amp; context, <span class="keyword">const</span> Identifier*&amp; directive, <span class="keyword">unsigned</span>* directiveLiteralLength)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (m_token.m_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> CONSTTOKEN:</span><br><span class="line">        result = <span class="built_in">parseVariableDeclaration</span>(context, DeclarationType::ConstDeclaration);</span><br><span class="line">        shouldSetPauseLocation = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LET: &#123;</span><br><span class="line">        <span class="keyword">bool</span> shouldParseVariableDeclaration = <span class="literal">true</span>;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (shouldParseVariableDeclaration)</span><br><span class="line">            result = <span class="built_in">parseVariableDeclaration</span>(context, DeclarationType::LetDeclaration);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">bool</span> allowFunctionDeclarationAsStatement = <span class="literal">true</span>;</span><br><span class="line">            result = <span class="built_in">parseExpressionOrLabelStatement</span>(context, allowFunctionDeclarationAsStatement);</span><br><span class="line">        &#125;</span><br><span class="line">        shouldSetPauseLocation = !context.<span class="built_in">shouldSkipPauseLocation</span>(result);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>In our <code>demo</code>, the <code>m_token.m_type</code> is <code>LET</code>, it will call <code>parseVariableDeclaration</code> to generate the variable declaration related <code>statement</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> LexerType&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">TreeBuilder</span>&gt;</span> TreeStatement Parser&lt;LexerType&gt;::<span class="built_in">parseVariableDeclaration</span>(TreeBuilder&amp; context, DeclarationType declarationType, ExportType exportType)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">ASSERT</span>(<span class="built_in">match</span>(VAR) || <span class="built_in">match</span>(LET) || <span class="built_in">match</span>(CONSTTOKEN));</span><br><span class="line">    <span class="function">JSTokenLocation <span class="title">location</span><span class="params">(tokenLocation())</span></span>;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="built_in">tokenLine</span>();</span><br><span class="line">    <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> scratch;</span><br><span class="line">    TreeDestructuringPattern scratch1 = <span class="number">0</span>;</span><br><span class="line">    TreeExpression scratch2 = <span class="number">0</span>;</span><br><span class="line">    JSTextPosition scratch3;</span><br><span class="line">    <span class="keyword">bool</span> scratchBool;</span><br><span class="line">    TreeExpression variableDecls = <span class="built_in">parseVariableDeclarationList</span>(context, scratch, scratch1, scratch2, scratch3, scratch3, scratch3, VarDeclarationContext, declarationType, exportType, scratchBool);</span><br><span class="line">    <span class="built_in">propagateError</span>();</span><br><span class="line">    <span class="built_in">failIfFalse</span>(<span class="built_in">autoSemiColon</span>(), <span class="string">&quot;Expected &#x27;;&#x27; after variable declaration&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> context.<span class="built_in">createDeclarationStatement</span>(location, variableDecls, start, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Continue to go with <code>let x = 10</code> as the example, the <code>parseVariableDeclarationList</code> will first creates a <code>AssignmentContext</code>, and then calls <code>next</code> to parse the <code>x</code> as <code>Identifier* name</code>. And then calls <code>next</code> to parse the <code>=</code>, which knows that it has the <code>initializer</code>. For it has the <code>initializer</code>, it need to call <code>parseAssignmentExpression</code> function to build the <code>initializer</code>(<code>rhs</code>). Once all the words are parsed, the <code>createAssignResolve</code> function will be called to generate the <code>VariableDeclaration statement</code> (<code>AST</code> node) and return.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parser/Parser.cpp: 861</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> LexerType&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">TreeBuilder</span>&gt;</span> TreeExpression Parser&lt;LexerType&gt;::<span class="built_in">parseVariableDeclarationList</span>(TreeBuilder&amp; </span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    AssignmentContext assignmentContext = <span class="built_in">assignmentContextFromDeclarationType</span>(declarationType);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="built_in">next</span>();</span><br><span class="line">        ...</span><br><span class="line">        declarations++;</span><br><span class="line">        <span class="keyword">bool</span> hasInitializer = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">failIfTrue</span>(<span class="built_in">match</span>(PRIVATENAME), <span class="string">&quot;Cannot use a private name to declare a variable&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">matchSpecIdentifier</span>()) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">const</span> Identifier* name = m_token.m_data.ident;</span><br><span class="line">            lastIdent = name;</span><br><span class="line">            lastIdentToken = m_token;</span><br><span class="line">            <span class="built_in">next</span>();</span><br><span class="line">            hasInitializer = <span class="built_in">match</span>(EQUAL);</span><br><span class="line">            DeclarationResultMask declarationResult = <span class="built_in">declareVariable</span>(name, declarationType);</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (hasInitializer) &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="built_in">next</span>(TreeBuilder::DontBuildStrings); <span class="comment">// consume &#x27;=&#x27;</span></span><br><span class="line">                ...</span><br><span class="line">                TreeExpression initializer = <span class="built_in">parseAssignmentExpression</span>(context);</span><br><span class="line">                ...</span><br><span class="line">                </span><br><span class="line">                node = context.<span class="built_in">createAssignResolve</span>(location, *name, initializer, varStart, varDivot, <span class="built_in">lastTokenEndPosition</span>(), assignmentContext);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ...</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>One <code>statement</code> has been built, the <code>parseSourceElements</code> will continue to traverse all the other source code to build the <code>AST</code> tree.</p>
<p><code>parseSourceElements</code> returns by creating an AST of <code>ParsedNode</code> elements. When <code>parse</code> returns without any syntax or semantic parsing errors, we have a valid AST with <code>rootNode</code> pointing to the root of the tree.</p>
<h2 id="Generate-unlinked-bytecode"><a href="#Generate-unlinked-bytecode" class="headerlink" title="Generate unlinked bytecode"></a>Generate unlinked bytecode</h2><p>As said before, i assume you are familiar with bytecode, so i won’t explain too much about the bytecode, if you need, just check the official post  <a target="_blank" rel="noopener" href="https://webkit.org/blog/9329/a-new-bytecode-format-for-javascriptcore/">A New Bytecode Format for JavaScriptCore</a>.</p>
<p>But to explain it more clearly, we need to give out the <code>demo.js</code>‘s bytecode here and explain a little about the bytecode. Add command line <code>-d</code> in the jsc, it will output the <code>bytecode</code> to <code>stderr</code>. The first line gives out the basic information, <code>18</code> instruction and <code>212</code> bytes. the <code>18</code> instructions are follow the first line, the number in the <code>[]</code> means the offset in the <code>bytecode stream</code>. And the <code>Identifiers</code>, and <code>Constants</code> are followed behind.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">$ ~/work/jsc/engine/WebKit/WebKitBuild/Debug/bin/jsc -d demo.js</span><br><span class="line">&lt;global&gt;#CR3m3u:[0x7f95897c0000-&gt;0x7f95ca1fa848, NoneGlobal, 96]: 18 instructions (0 16-bit instructions, 0 32-bit instructions, 10 instructions with metadata); 212 bytes (116 metadata bytes); 1 parameter(s); 12 callee register(s); 6 variable(s); scope at loc4</span><br><span class="line"></span><br><span class="line">bb#1</span><br><span class="line">Predecessors: [ ]</span><br><span class="line">[   0] enter</span><br><span class="line">[   1] get_scope          dst:loc4</span><br><span class="line">[   3] mov                dst:loc5, src:loc4</span><br><span class="line">[   6] check_traps</span><br><span class="line">[   7] mov                dst:loc6, src:Undefined(const0)</span><br><span class="line">[  10] resolve_scope      dst:loc7, scope:loc4, var:0, resolveType:GlobalProperty, localScopeDepth:0</span><br><span class="line">[  17] put_to_scope       scope:loc7, var:0, value:Int32: 10(const1), getPutInfo:1048576&lt;DoNotThrowIfNotFound|GlobalProperty|Initialization|NotStrictMode&gt;, symbolTableOrScopeDepth:0, offset:0</span><br><span class="line">[  25] resolve_scope      dst:loc7, scope:loc4, var:1, resolveType:GlobalProperty, localScopeDepth:0</span><br><span class="line">[  32] put_to_scope       scope:loc7, var:1, value:Int32: 20(const2), getPutInfo:1048576&lt;DoNotThrowIfNotFound|GlobalProperty|Initialization|NotStrictMode&gt;, symbolTableOrScopeDepth:0, offset:0</span><br><span class="line">[  40] resolve_scope      dst:loc7, scope:loc4, var:2, resolveType:GlobalProperty, localScopeDepth:0</span><br><span class="line">[  47] resolve_scope      dst:loc8, scope:loc4, var:0, resolveType:GlobalProperty, localScopeDepth:0</span><br><span class="line">[  54] get_from_scope     dst:loc9, scope:loc8, var:0, getPutInfo:2048&lt;ThrowIfNotFound|GlobalProperty|NotInitialization|NotStrictMode&gt;, localScopeDepth:0, offset:0</span><br><span class="line">[  62] mov                dst:loc8, src:loc9</span><br><span class="line">[  65] resolve_scope      dst:loc9, scope:loc4, var:1, resolveType:GlobalProperty, localScopeDepth:0</span><br><span class="line">[  72] get_from_scope     dst:loc10, scope:loc9, var:1, getPutInfo:2048&lt;ThrowIfNotFound|GlobalProperty|NotInitialization|NotStrictMode&gt;, localScopeDepth:0, offset:0</span><br><span class="line">[  80] add                dst:loc8, lhs:loc8, rhs:loc10, profileIndex:0, operandTypes:OperandTypes(126, 126)</span><br><span class="line">[  86] put_to_scope       scope:loc7, var:2, value:loc8, getPutInfo:1048576&lt;DoNotThrowIfNotFound|GlobalProperty|Initialization|NotStrictMode&gt;, symbolTableOrScopeDepth:0, offset:0</span><br><span class="line">[  94] end                value:loc6</span><br><span class="line">Successors: [ ]</span><br><span class="line"></span><br><span class="line">Identifiers:</span><br><span class="line">  id0 = x</span><br><span class="line">  id1 = y</span><br><span class="line">  id2 = z</span><br><span class="line"></span><br><span class="line">Constants:</span><br><span class="line">   k0 = Undefined</span><br><span class="line">   k1 = Int32: 10: in source as integer</span><br><span class="line">   k2 = Int32: 20: in source as integer</span><br><span class="line"></span><br><span class="line">End: undefined</span><br></pre></td></tr></table></figure>

<p>Now we can continue to explain the generation of <code>unlinked</code> bytecode. We have finished the analysis of Parsing js source to <code>AST</code>, the <code>parse</code> function goes back to <code>generateUnlinkedCodeBlockImpl</code>, and <code>generateUnlinkedCodeBlockImpl</code> invokes <code>UnlinkedCodeBlockType::create</code> to allocate the <code>unlinkedCodeBlock</code> object which is used to store the <code>unlinked</code> bytecode, and finally it calls <code>BytecodeGenerator::generate</code> to generate the <code>unlinked</code> bytecode. So in this section, the most important function is <code>BytecodeGenerator::generate</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/CodeCache.cpp: 73</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">UnlinkedCodeBlockType</span>, <span class="keyword">class</span> <span class="title">ExecutableType</span> =</span> ScriptExecutable&gt;</span><br><span class="line"><span class="function">UnlinkedCodeBlockType* <span class="title">generateUnlinkedCodeBlockImpl</span><span class="params">(VM&amp; vm, <span class="keyword">const</span> SourceCode&amp; source, JSParserStrictMode </span></span></span><br><span class="line"><span class="params"><span class="function">...</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    ...</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">    std::unique_ptr&lt;RootNode&gt; rootNode = parse&lt;RootNode&gt;(</span></span></span><br><span class="line"><span class="params"><span class="function">        vm, source, Identifier(), JSParserBuiltinMode::NotBuiltin, strictMode, scriptMode, CacheTypes&lt;UnlinkedCodeBlockType&gt;::parseMode, SuperBinding::NotNeeded, error, <span class="literal">nullptr</span>, ConstructorKind::None, derivedContextType, evalContextType, <span class="literal">nullptr</span>, privateNameEnvironment, <span class="literal">nullptr</span>, isInsideOrdinaryFunction);</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">if</span> (!rootNode)</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">    ...</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">    UnlinkedCodeBlockType* unlinkedCodeBlock = UnlinkedCodeBlockType::create(vm, executableInfo, codeGenerationMode);</span></span></span><br><span class="line"><span class="params"><span class="function">    ...</span></span></span><br><span class="line"><span class="params"><span class="function">    error = BytecodeGenerator::generate(vm, rootNode.get(), source, unlinkedCodeBlock, codeGenerationMode, parentVariablesUnderTDZ, privateNameEnvironment);</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">if</span> (error.isValid())</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">return</span> unlinkedCodeBlock;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br></pre></td></tr></table></figure>

<p>Dive into <code>BytecodeGenerator::generate</code> funciton, it will first allocate a <code>bytecodeGenerator</code>, and then calls <code>bytecodeGenerator-&gt;generate</code> function to generate the <code>unlinked</code> bytecode.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// bytecompiler/BytecodeGenerator.h: 378</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Node, <span class="keyword">typename</span> UnlinkedCodeBlock&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">static</span> ParserError <span class="title">generate</span><span class="params">(VM&amp; vm, Node* node, <span class="keyword">const</span> SourceCode&amp; sourceCode, UnlinkedCodeBlock* unlinkedCodeBlock, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, <span class="keyword">const</span> RefPtr&lt;TDZEnvironmentLink&gt;&amp; parentScopeTDZVariables, <span class="keyword">const</span> PrivateNameEnvironment* privateNameEnvironment)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">auto</span> bytecodeGenerator = makeUnique&lt;BytecodeGenerator&gt;(vm, node, unlinkedCodeBlock, codeGenerationMode, parentScopeTDZVariables, privateNameEnvironment);</span><br><span class="line">        <span class="keyword">unsigned</span> size;</span><br><span class="line">        <span class="keyword">auto</span> result = bytecodeGenerator-&gt;<span class="built_in">generate</span>(size);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>The <code>bytecodeGenerator</code> is initialized with supplied <code>AST</code> tree, and emit the program prologue. <code>emitEnter</code> emits <code>enter</code> bytecode and <code>emitCheckTraps</code> emits <code>check_traps</code> bytecode.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bytecompiler/BytecodeGenerator.cpp: 295</span></span><br><span class="line">BytecodeGenerator::<span class="built_in">BytecodeGenerator</span>(VM&amp; vm, ProgramNode* programNode, UnlinkedProgramCodeBlock* codeBlock, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, <span class="keyword">const</span> RefPtr&lt;TDZEnvironmentLink&gt;&amp; parentScopeTDZVariables, <span class="keyword">const</span> PrivateNameEnvironment*)</span><br><span class="line">    : <span class="built_in">BytecodeGeneratorBase</span>(makeUnique&lt;UnlinkedCodeBlockGenerator&gt;(vm, codeBlock), CodeBlock::<span class="built_in">llintBaselineCalleeSaveSpaceAsVirtualRegisters</span>())</span><br><span class="line">    , <span class="built_in">m_codeGenerationMode</span>(codeGenerationMode)</span><br><span class="line">    , <span class="built_in">m_scopeNode</span>(programNode)</span><br><span class="line">    ...</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">ASSERT_UNUSED</span>(parentScopeTDZVariables, !parentScopeTDZVariables);</span><br><span class="line"></span><br><span class="line">    m_codeBlock-&gt;<span class="built_in">setNumParameters</span>(<span class="number">1</span>); <span class="comment">// Allocate space for &quot;this&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">emitEnter</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">allocateAndEmitScope</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">emitCheckTraps</span>();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Follow into the <code>bytecodeGenerator-&gt;generate</code> function, it calls <code>m_scopeNode-&gt;emitBytecode</code> to generate the <code>unlinked</code> bytecode and then emits all the <code>exception handler</code> for the program, and at last call <code>m_codeBlock-&gt;finalize</code> to finalize the bytecode.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bytecompiler/BytecodeGenerator.cpp: 151</span></span><br><span class="line"><span class="function">ParserError <span class="title">BytecodeGenerator::generate</span><span class="params">(<span class="keyword">unsigned</span>&amp; size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">        m_scopeNode-&gt;<span class="built_in">emitBytecode</span>(*<span class="keyword">this</span>);</span><br><span class="line">			...</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; handler : m_exceptionHandlersToEmit) &#123;</span><br><span class="line">        Ref&lt;Label&gt; realCatchTarget = <span class="built_in">newLabel</span>();</span><br><span class="line">        TryData* tryData = handler.tryData;</span><br><span class="line"></span><br><span class="line">        OpCatch::<span class="built_in">emit</span>(<span class="keyword">this</span>, handler.exceptionRegister, handler.thrownValueRegister);</span><br><span class="line">        realCatchTarget-&gt;<span class="built_in">setLocation</span>(*<span class="keyword">this</span>, m_lastInstruction.<span class="built_in">offset</span>());</span><br><span class="line">        <span class="keyword">if</span> (handler.completionTypeRegister.<span class="built_in">isValid</span>()) &#123;</span><br><span class="line">            RegisterID completionTypeRegister &#123; handler.completionTypeRegister &#125;;</span><br><span class="line">            CompletionType completionType =</span><br><span class="line">                tryData-&gt;handlerType == HandlerType::Finally || tryData-&gt;handlerType == HandlerType::SynthesizedFinally</span><br><span class="line">                ? CompletionType::Throw</span><br><span class="line">                : CompletionType::Normal;</span><br><span class="line">            <span class="built_in">emitLoad</span>(&amp;completionTypeRegister, completionType);</span><br><span class="line">        &#125;</span><br><span class="line">        m_codeBlock-&gt;<span class="built_in">addJumpTarget</span>(m_lastInstruction.<span class="built_in">offset</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">emitJump</span>(tryData-&gt;target.<span class="built_in">get</span>());</span><br><span class="line">        tryData-&gt;target = <span class="built_in">WTFMove</span>(realCatchTarget);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		...</span><br><span class="line">    m_codeBlock-&gt;<span class="built_in">finalize</span>(m_writer.<span class="built_in">finalize</span>());</span><br></pre></td></tr></table></figure>

<p>For <code>m_scopeNode</code> is a <code>ProgramNode</code>, the corresponding <code>emitBytecode</code> is <code>ProgramNode::emitBytecode</code>, it inner calls  <code>emitProgramNodeBytecode</code> function.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bytecompiler/NodesCodegen.cpp: 4777</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProgramNode::emitBytecode</span><span class="params">(BytecodeGenerator&amp; generator, RegisterID*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">emitProgramNodeBytecode</span>(generator, *<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In <code>emitProgramNodeBytecode</code> function, it will first call <code>generator.emitLoad</code> to emits a <code>load</code> bytecode, which in the <code>demo</code> is <code>mov                dst:loc6, src:Undefined(const0)</code>, and then calls <code>scopeNode.emitStatementsBytecode</code> function to traverse the <code>AST</code> tree to generate the <code>unlinked</code> bytecode.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bytecompiler/NodesCodegen.cpp: 4762</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">emitProgramNodeBytecode</span><span class="params">(BytecodeGenerator&amp; generator, ScopeNode&amp; scopeNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    generator.<span class="built_in">emitDebugHook</span>(WillExecuteProgram, scopeNode.<span class="built_in">startLine</span>(), scopeNode.<span class="built_in">startStartOffset</span>(), scopeNode.<span class="built_in">startLineStartOffset</span>());</span><br><span class="line"></span><br><span class="line">    RefPtr&lt;RegisterID&gt; dstRegister = generator.<span class="built_in">newTemporary</span>();</span><br><span class="line">    generator.<span class="built_in">emitLoad</span>(dstRegister.<span class="built_in">get</span>(), <span class="built_in">jsUndefined</span>());</span><br><span class="line">    generator.<span class="built_in">emitProfileControlFlow</span>(scopeNode.<span class="built_in">startStartOffset</span>());</span><br><span class="line">    scopeNode.<span class="built_in">emitStatementsBytecode</span>(generator, dstRegister.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">    generator.<span class="built_in">emitDebugHook</span>(DidExecuteProgram, scopeNode.<span class="built_in">lastLine</span>(), scopeNode.<span class="built_in">startOffset</span>(), scopeNode.<span class="built_in">lineStartOffset</span>());</span><br><span class="line">    generator.<span class="built_in">emitEnd</span>(dstRegister.<span class="built_in">get</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Get into the <code>ScopeNode::emitStatementsBytecode</code> function, we can see it calls <code>emitBytecode</code> function for the <code>AST</code> tree <code>m_statements</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bytecompiler/NodesCodegen.cpp: 4755</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ScopeNode::emitStatementsBytecode</span><span class="params">(BytecodeGenerator&amp; generator, RegisterID* dst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!m_statements)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    m_statements-&gt;<span class="built_in">emitBytecode</span>(generator, dst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In <code>SourceElements::emitBytecode</code> function, it traverses the <code>AST</code> tree, and calls <code>emitNodeInTailPosition</code> for each <code>AST</code> node(<code>statment</code>). </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bytecompiler/NodesCodegen.cpp: 3804</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">SourceElements::emitBytecode</span><span class="params">(BytecodeGenerator&amp; generator, RegisterID* dst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    StatementNode* lastStatementWithCompletionValue = <span class="literal">nullptr</span>;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (StatementNode* statement = m_head; statement; statement = statement-&gt;<span class="built_in">next</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (statement == lastStatementWithCompletionValue)</span><br><span class="line">            generator.<span class="built_in">emitLoad</span>(dst, <span class="built_in">jsUndefined</span>());</span><br><span class="line">        generator.<span class="built_in">emitNodeInTailPosition</span>(dst, statement);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">				</span><br></pre></td></tr></table></figure>

<p>As the code shows, <code>emitNodeInTailPosition</code> function will call the corresponding <code>statement</code>‘s(<code>opcode</code>) <code>emitBytecode</code> function.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bytecompiler/NodesCodegen.cpp: 475</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">emitNodeInTailPosition</span><span class="params">(RegisterID* dst, StatementNode* n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        n-&gt;<span class="built_in">emitBytecode</span>(*<span class="keyword">this</span>, dst);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>The various opcodes are defined in <a target="_blank" rel="noopener" href="https://github.com/WebKit/WebKit/blob/main/Source/JavaScriptCore/bytecode/BytecodeList.rb"><code>BytecodeList.rb</code></a> which at compile time is used to generate <code>BytecodeStructs.h</code> which is referenced by the <code>BytecodeGenerator</code> to emit the relevant opcodes(<code>statement</code>). The structs for the various opcodes also define several helper functions, one of which allows dumping bytecodes to stdout in a human readable format. <code>BytecodeStructs.h</code> is typically located under <code>&lt;build-directory&gt;/Debug/DerivedSources/JavaScriptCore/BytecodeStructs.h</code>. An example of the <code>OpAdd</code> instruction is shown below:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DerivedSources/JavaScriptCore/BytecodeStructs.h: 3731</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OpAdd</span> :</span> <span class="keyword">public</span> Instruction &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> OpcodeID opcodeID = op_add;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">size_t</span> length = <span class="number">6</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> BytecodeGenerator&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">emit</span><span class="params">(BytecodeGenerator* gen, VirtualRegister dst, VirtualRegister lhs, VirtualRegister rhs, OperandTypes operandTypes)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        emitWithSmallestSizeRequirement&lt;OpcodeSize::Narrow, BytecodeGenerator&gt;(gen, dst, lhs, rhs, operandTypes);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">   <span class="function"><span class="keyword">template</span>&lt;OpcodeSize __size, <span class="keyword">bool</span> recordOpcode, <span class="keyword">typename</span> BytecodeGenerator&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">emitImpl</span><span class="params">(BytecodeGenerator* gen, VirtualRegister dst, VirtualRegister lhs, VirtualRegister rhs, OperandTypes operandTypes, <span class="keyword">unsigned</span> __metadataID)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (__size == OpcodeSize::Wide16)</span><br><span class="line">            gen-&gt;<span class="built_in">alignWideOpcode16</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (__size == OpcodeSize::Wide32)</span><br><span class="line">            gen-&gt;<span class="built_in">alignWideOpcode32</span>();</span><br><span class="line">        <span class="keyword">if</span> (checkImpl&lt;__size&gt;(gen, dst, lhs, rhs, operandTypes, __metadataID)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (recordOpcode)</span><br><span class="line">                gen-&gt;<span class="built_in">recordOpcode</span>(opcodeID);</span><br><span class="line">            <span class="keyword">if</span> (__size == OpcodeSize::Wide16)</span><br><span class="line">                gen-&gt;<span class="built_in">write</span>(Fits&lt;OpcodeID, OpcodeSize::Narrow&gt;::<span class="built_in">convert</span>(op_wide16));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (__size == OpcodeSize::Wide32)</span><br><span class="line">                gen-&gt;<span class="built_in">write</span>(Fits&lt;OpcodeID, OpcodeSize::Narrow&gt;::<span class="built_in">convert</span>(op_wide32));</span><br><span class="line">            gen-&gt;<span class="built_in">write</span>(Fits&lt;OpcodeID, OpcodeSize::Narrow&gt;::<span class="built_in">convert</span>(opcodeID));</span><br><span class="line">            gen-&gt;<span class="built_in">write</span>(Fits&lt;VirtualRegister, __size&gt;::<span class="built_in">convert</span>(dst));</span><br><span class="line">            gen-&gt;<span class="built_in">write</span>(Fits&lt;VirtualRegister, __size&gt;::<span class="built_in">convert</span>(lhs));</span><br><span class="line">            gen-&gt;<span class="built_in">write</span>(Fits&lt;VirtualRegister, __size&gt;::<span class="built_in">convert</span>(rhs));</span><br><span class="line">            gen-&gt;<span class="built_in">write</span>(Fits&lt;OperandTypes, __size&gt;::<span class="built_in">convert</span>(operandTypes));</span><br><span class="line">            gen-&gt;<span class="built_in">write</span>(Fits&lt;<span class="keyword">unsigned</span>, __size&gt;::<span class="built_in">convert</span>(__metadataID));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dump</span><span class="params">(BytecodeDumperBase* dumper, InstructionStream::Offset __location, <span class="keyword">int</span> __sizeShiftAmount)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        dumper-&gt;<span class="built_in">printLocationAndOp</span>(__location, &amp;<span class="string">&quot;**add&quot;</span>[<span class="number">2</span> - __sizeShiftAmount]);</span><br><span class="line">        dumper-&gt;<span class="built_in">dumpOperand</span>(<span class="string">&quot;dst&quot;</span>, m_dst, <span class="literal">true</span>);</span><br><span class="line">        dumper-&gt;<span class="built_in">dumpOperand</span>(<span class="string">&quot;lhs&quot;</span>, m_lhs, <span class="literal">false</span>);</span><br><span class="line">        dumper-&gt;<span class="built_in">dumpOperand</span>(<span class="string">&quot;rhs&quot;</span>, m_rhs, <span class="literal">false</span>);</span><br><span class="line">        dumper-&gt;<span class="built_in">dumpOperand</span>(<span class="string">&quot;operandTypes&quot;</span>, m_operandTypes, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">		...</span><br><span class="line">    VirtualRegister m_dst;</span><br><span class="line">    VirtualRegister m_lhs;</span><br><span class="line">    VirtualRegister m_rhs;</span><br><span class="line">    OperandTypes m_operandTypes;</span><br><span class="line">    <span class="keyword">unsigned</span> m_metadataID;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Because our demo’s first <code>statement</code> is <code>DeclarationStatement</code>, so it will call <code>DeclarationStatement::emitBytecode</code>.  Follow the execution flow, it will call <code>AssignResolveNode::emitBytecode</code> function at the end.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bytecompiler/NodesCodegen.cpp: 3856</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeclarationStatement::emitBytecode</span><span class="params">(BytecodeGenerator&amp; generator, RegisterID*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ASSERT</span>(m_expr);</span><br><span class="line">    generator.<span class="built_in">emitNode</span>(m_expr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// bytecompiler/BytecodeGenerator.h: 520</span></span><br><span class="line">				<span class="function">RegisterID* <span class="title">emitNode</span><span class="params">(ExpressionNode* n)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">emitNode</span>(<span class="literal">nullptr</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">				...</span><br><span class="line">        <span class="comment">// bytecompiler/BytecodeGenerator.h: 503</span></span><br><span class="line">        <span class="function">RegisterID* <span class="title">emitNode</span><span class="params">(RegisterID* dst, ExpressionNode* n)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="function">SetForScope&lt;<span class="keyword">bool</span>&gt; <span class="title">tailPositionPoisoner</span><span class="params">(m_inTailPosition, <span class="literal">false</span>)</span></span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">emitNodeInTailPosition</span>(dst, n);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><code>AssignResolveNode::emitBytecode</code> function first involkes <code>emitResolveScope</code> function to emit <code>resolve_scope</code> bytecode, which in our example is <code>[  10] resolve_scope      dst:loc7, scope:loc4, var:0, resolveType:GlobalProperty, localScopeDepth:0</code>. And then call <code>generator.emitNode</code> function to emit <code>load</code> for our value, for the value is <code>constant 10</code>, so there is no load. At last it call <code>emitPutToScope</code> to emits <code>put_to_scope</code> bytecode.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bytecompiler/BytecodeGenerator.h: 3573</span></span><br><span class="line"><span class="function">RegisterID* <span class="title">AssignResolveNode::emitBytecode</span><span class="params">(BytecodeGenerator&amp; generator, RegisterID* dst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    RefPtr&lt;RegisterID&gt; scope = generator.<span class="built_in">emitResolveScope</span>(<span class="literal">nullptr</span>, var);</span><br><span class="line">    <span class="keyword">if</span> (m_assignmentContext == AssignmentContext::AssignmentExpression)</span><br><span class="line">        generator.<span class="built_in">emitTDZCheckIfNecessary</span>(var, <span class="literal">nullptr</span>, scope.<span class="built_in">get</span>());</span><br><span class="line">    <span class="keyword">if</span> (dst == generator.<span class="built_in">ignoredResult</span>())</span><br><span class="line">        dst = <span class="literal">nullptr</span>;</span><br><span class="line">    RefPtr&lt;RegisterID&gt; result = generator.<span class="built_in">emitNode</span>(dst, m_right); <span class="comment">// Execute side effects first.</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!isReadOnly) &#123;</span><br><span class="line">        returnResult = generator.<span class="built_in">emitPutToScope</span>(scope.<span class="built_in">get</span>(), var, result.<span class="built_in">get</span>(), generator.<span class="built_in">ecmaMode</span>().<span class="built_in">isStrict</span>() ? ThrowIfNotFound : DoNotThrowIfNotFound, <span class="built_in">initializationModeForAssignmentContext</span>(m_assignmentContext));</span><br><span class="line">        generator.<span class="built_in">emitProfileType</span>(result.<span class="built_in">get</span>(), var, <span class="built_in">divotStart</span>(), <span class="built_in">divotEnd</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> returnResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>I want to trace more to figure out how the bytecode is generated, so i take <code>emitResolveScope</code> as a example to see how the <code>unlinked</code> bytecode <code>resolve_scope</code> is generated. Get into the function, we can see it will call  <code>OpResolveScope::emit</code> function according to <code>variable.offset().kind()</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bytecompiler/BytecodeGenerator.cpp: 2465</span></span><br><span class="line"><span class="function">RegisterID* <span class="title">BytecodeGenerator::emitResolveScope</span><span class="params">(RegisterID* dst, <span class="keyword">const</span> Variable&amp; variable)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (variable.<span class="built_in">offset</span>().<span class="built_in">kind</span>()) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> VarKind::Invalid:</span><br><span class="line">        <span class="comment">// Indicates non-local resolution.</span></span><br><span class="line">        </span><br><span class="line">        dst = <span class="built_in">tempDestination</span>(dst);</span><br><span class="line">        OpResolveScope::<span class="built_in">emit</span>(<span class="keyword">this</span>, <span class="built_in">kill</span>(dst), <span class="built_in">scopeRegister</span>(), <span class="built_in">addConstant</span>(variable.<span class="built_in">ident</span>()), <span class="built_in">resolveType</span>(), <span class="built_in">localScopeDepth</span>());</span><br><span class="line">        <span class="keyword">return</span> dst;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">RELEASE_ASSERT_NOT_REACHED</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>As said before, opcodes are defined in <a target="_blank" rel="noopener" href="https://github.com/WebKit/WebKit/blob/main/Source/JavaScriptCore/bytecode/BytecodeList.rb"><code>BytecodeList.rb</code></a>, and the generators for the opcodes are generated at compile time which finnally are stored in  <code>&lt;build-directory&gt;/Debug/DerivedSources/JavaScriptCore/BytecodeStructs.h</code>. So follow the <code>OpResolveScope::emit</code> will trace into the <code>OpResolveScope</code> related generator. The generator is shown as below, as we can see, it will finally call  <code>gen-&gt;write</code> to write the specific byte to the bytecode array.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DerivedSources/JavaScriptCore/BytecodeStructs.h: 12331</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OpResolveScope</span> :</span> <span class="keyword">public</span> Instruction &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> OpcodeID opcodeID = op_resolve_scope;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">size_t</span> length = <span class="number">7</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> BytecodeGenerator&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">emit</span><span class="params">(BytecodeGenerator* gen, VirtualRegister dst, VirtualRegister scope, <span class="keyword">unsigned</span> var, ResolveType resolveType, <span class="keyword">unsigned</span> localScopeDepth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        emitWithSmallestSizeRequirement&lt;OpcodeSize::Narrow, BytecodeGenerator&gt;(gen, dst, scope, var, resolveType, localScopeDepth);</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;OpcodeSize __size, <span class="keyword">typename</span> BytecodeGenerator&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">emitWithSmallestSizeRequirement</span><span class="params">(BytecodeGenerator* gen, VirtualRegister dst, VirtualRegister scope, <span class="keyword">unsigned</span> var, ResolveType resolveType, <span class="keyword">unsigned</span> localScopeDepth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> __metadataID = gen-&gt;<span class="built_in">addMetadataFor</span>(opcodeID);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span>&gt;(__size) &lt;= <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span>&gt;(OpcodeSize::Narrow)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (emit&lt;OpcodeSize::Narrow, BytecodeGenerator, NoAssert, <span class="literal">true</span>&gt;(gen, dst, scope, var, resolveType, localScopeDepth, __metadataID))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">  	...</span><br><span class="line">		<span class="function"><span class="keyword">template</span>&lt;OpcodeSize __size, <span class="keyword">bool</span> recordOpcode, <span class="keyword">typename</span> BytecodeGenerator&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">emitImpl</span><span class="params">(BytecodeGenerator* gen, VirtualRegister dst, VirtualRegister scope, <span class="keyword">unsigned</span> var, ResolveType resolveType, <span class="keyword">unsigned</span> localScopeDepth, <span class="keyword">unsigned</span> __metadataID)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (__size == OpcodeSize::Wide16)</span><br><span class="line">            gen-&gt;<span class="built_in">alignWideOpcode16</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (__size == OpcodeSize::Wide32)</span><br><span class="line">            gen-&gt;<span class="built_in">alignWideOpcode32</span>();</span><br><span class="line">        <span class="keyword">if</span> (checkImpl&lt;__size&gt;(gen, dst, scope, var, resolveType, localScopeDepth, __metadataID)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (recordOpcode)</span><br><span class="line">                gen-&gt;<span class="built_in">recordOpcode</span>(opcodeID);</span><br><span class="line">            <span class="keyword">if</span> (__size == OpcodeSize::Wide16)</span><br><span class="line">                gen-&gt;<span class="built_in">write</span>(Fits&lt;OpcodeID, OpcodeSize::Narrow&gt;::<span class="built_in">convert</span>(op_wide16));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (__size == OpcodeSize::Wide32)</span><br><span class="line">                gen-&gt;<span class="built_in">write</span>(Fits&lt;OpcodeID, OpcodeSize::Narrow&gt;::<span class="built_in">convert</span>(op_wide32));</span><br><span class="line">            gen-&gt;<span class="built_in">write</span>(Fits&lt;OpcodeID, OpcodeSize::Narrow&gt;::<span class="built_in">convert</span>(opcodeID));</span><br><span class="line">            gen-&gt;<span class="built_in">write</span>(Fits&lt;VirtualRegister, __size&gt;::<span class="built_in">convert</span>(dst));</span><br><span class="line">            gen-&gt;<span class="built_in">write</span>(Fits&lt;VirtualRegister, __size&gt;::<span class="built_in">convert</span>(scope));</span><br><span class="line">            gen-&gt;<span class="built_in">write</span>(Fits&lt;<span class="keyword">unsigned</span>, __size&gt;::<span class="built_in">convert</span>(var));</span><br><span class="line">            gen-&gt;<span class="built_in">write</span>(Fits&lt;ResolveType, __size&gt;::<span class="built_in">convert</span>(resolveType));</span><br><span class="line">            gen-&gt;<span class="built_in">write</span>(Fits&lt;<span class="keyword">unsigned</span>, __size&gt;::<span class="built_in">convert</span>(localScopeDepth));</span><br><span class="line">            gen-&gt;<span class="built_in">write</span>(Fits&lt;<span class="keyword">unsigned</span>, __size&gt;::<span class="built_in">convert</span>(__metadataID));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dump</span><span class="params">(BytecodeDumperBase* dumper, InstructionStream::Offset __location, <span class="keyword">int</span> __sizeShiftAmount)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        dumper-&gt;<span class="built_in">printLocationAndOp</span>(__location, &amp;<span class="string">&quot;**resolve_scope&quot;</span>[<span class="number">2</span> - __sizeShiftAmount]);</span><br><span class="line">        dumper-&gt;<span class="built_in">dumpOperand</span>(<span class="string">&quot;dst&quot;</span>, m_dst, <span class="literal">true</span>);</span><br><span class="line">        dumper-&gt;<span class="built_in">dumpOperand</span>(<span class="string">&quot;scope&quot;</span>, m_scope, <span class="literal">false</span>);</span><br><span class="line">        dumper-&gt;<span class="built_in">dumpOperand</span>(<span class="string">&quot;var&quot;</span>, m_var, <span class="literal">false</span>);</span><br><span class="line">        dumper-&gt;<span class="built_in">dumpOperand</span>(<span class="string">&quot;resolveType&quot;</span>, m_resolveType, <span class="literal">false</span>);</span><br><span class="line">        dumper-&gt;<span class="built_in">dumpOperand</span>(<span class="string">&quot;localScopeDepth&quot;</span>, m_localScopeDepth, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Right now we have figured out the way that <code>BytecodeGenerator::generate</code> function traverses the <code>AST</code> tree and generate the <code>bytecode</code> stream. After all the <code>bytecode</code> is generated, which is stored in <code>m_writer</code>, it will call <code>m_codeBlock-&gt;finalize(m_writer.finalize())</code> to finalize the final <code>unlinked</code> bytecode.</p>
<p>Let’s get into <code>finalize</code> function, it will first copy the <code>instructions</code> to <code>m_instructions</code>, and then allocate <code>ArithProfile</code> for the bytecode, and then call <code>m_metadata-&gt;finalize</code> to allocate <code>metadata</code> for bytecode, the rest is the other assignment, such as <code>m_jumpTargets</code>, <code>m_identifiers</code> and <code>m_functionExprs</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bytecode/UnlinkedCodeBlockGenerator.cpp: 116    </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UnlinkedCodeBlockGenerator::finalize</span><span class="params">(std::unique_ptr&lt;InstructionStream&gt; instructions)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ASSERT</span>(instructions);</span><br><span class="line">    &#123;</span><br><span class="line">        Locker locker &#123; m_codeBlock-&gt;<span class="built_in">cellLock</span>() &#125;;</span><br><span class="line">        m_codeBlock-&gt;m_instructions = <span class="built_in">WTFMove</span>(instructions);</span><br><span class="line">        m_codeBlock-&gt;<span class="built_in">allocateSharedProfiles</span>(m_numBinaryArithProfiles, m_numUnaryArithProfiles);</span><br><span class="line">        m_codeBlock-&gt;m_metadata-&gt;<span class="built_in">finalize</span>();</span><br><span class="line"></span><br><span class="line">        m_codeBlock-&gt;m_jumpTargets = <span class="built_in">WTFMove</span>(m_jumpTargets);</span><br><span class="line">        m_codeBlock-&gt;m_identifiers = <span class="built_in">WTFMove</span>(m_identifiers);</span><br><span class="line">        m_codeBlock-&gt;m_constantRegisters = <span class="built_in">WTFMove</span>(m_constantRegisters);</span><br><span class="line">        m_codeBlock-&gt;m_constantsSourceCodeRepresentation = <span class="built_in">WTFMove</span>(m_constantsSourceCodeRepresentation);</span><br><span class="line">        m_codeBlock-&gt;m_functionDecls = <span class="built_in">WTFMove</span>(m_functionDecls);</span><br><span class="line">        m_codeBlock-&gt;m_functionExprs = <span class="built_in">WTFMove</span>(m_functionExprs);</span><br><span class="line">        m_codeBlock-&gt;m_expressionInfo = <span class="built_in">WTFMove</span>(m_expressionInfo);</span><br><span class="line">        m_codeBlock-&gt;m_outOfLineJumpTargets = <span class="built_in">WTFMove</span>(m_outOfLineJumpTargets);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bytecode/UnlinkedMetadataTable.cpp: 39  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UnlinkedMetadataTable::finalize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ASSERT</span>(!m_isFinalized);</span><br><span class="line">    m_isFinalized = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!m_hasMetadata) &#123;</span><br><span class="line">        MetadataTableMalloc::<span class="built_in">free</span>(m_rawBuffer);</span><br><span class="line">        m_rawBuffer = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> offset = s_offset16TableSize;</span><br><span class="line">    &#123;</span><br><span class="line">        Offset32* buffer = <span class="built_in">preprocessBuffer</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; s_offsetTableEntries - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> numberOfEntries = buffer[i];</span><br><span class="line">            <span class="keyword">if</span> (!numberOfEntries) &#123;</span><br><span class="line">                buffer[i] = offset;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            buffer[i] = offset; <span class="comment">// We align when we access this.</span></span><br><span class="line">            <span class="keyword">unsigned</span> alignment = <span class="built_in">metadataAlignment</span>(<span class="keyword">static_cast</span>&lt;OpcodeID&gt;(i));</span><br><span class="line">            offset = <span class="built_in">roundUpToMultipleOf</span>(alignment, offset);</span><br><span class="line">            <span class="built_in">ASSERT</span>(alignment &lt;= s_maxMetadataAlignment);</span><br><span class="line">            offset += numberOfEntries * <span class="built_in">metadataSize</span>(<span class="keyword">static_cast</span>&lt;OpcodeID&gt;(i));</span><br><span class="line">        &#125;</span><br><span class="line">        buffer[s_offsetTableEntries - <span class="number">1</span>] = offset;</span><br><span class="line">        m_is32Bit = offset &gt; UINT16_MAX;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_is32Bit) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Offset32* oldBuffer = bitwise_cast&lt;Offset32*&gt;(m_rawBuffer + <span class="built_in"><span class="keyword">sizeof</span></span>(LinkingData));</span><br><span class="line">        Offset16* buffer = bitwise_cast&lt;Offset16*&gt;(m_rawBuffer + <span class="built_in"><span class="keyword">sizeof</span></span>(LinkingData));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; s_offsetTableEntries; i++)</span><br><span class="line">            buffer[i] = oldBuffer[i];</span><br><span class="line">        m_rawBuffer = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(MetadataTableMalloc::<span class="built_in">realloc</span>(m_rawBuffer, s_offset16TableSize + <span class="built_in"><span class="keyword">sizeof</span></span>(LinkingData)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Generate-linked-bytecode"><a href="#Generate-linked-bytecode" class="headerlink" title="Generate linked bytecode"></a>Generate linked bytecode</h2><p>Now that we have finished analysis of <code>initializeGlobalProperties</code> function and <code>unlinked</code> bytecode is generated, we can go back  <code>executeProgram</code> to move to the next step.  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interpreter/Interpreter.cpp: 709</span></span><br><span class="line"><span class="function">JSValue <span class="title">Interpreter::executeProgram</span><span class="params">(<span class="keyword">const</span> SourceCode&amp; source, JSGlobalObject*, JSObject* thisObj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    JSObject* error = program-&gt;<span class="built_in">initializeGlobalProperties</span>(vm, globalObject, scope);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    ProgramCodeBlock* codeBlock;</span><br><span class="line">    &#123;</span><br><span class="line">        CodeBlock* tempCodeBlock;</span><br><span class="line">        program-&gt;prepareForExecution&lt;ProgramExecutable&gt;(vm, <span class="literal">nullptr</span>, scope, CodeForCall, tempCodeBlock);</span><br><span class="line">        <span class="built_in">RETURN_IF_EXCEPTION</span>(throwScope, <span class="built_in">checkedReturn</span>(throwScope.<span class="built_in">exception</span>()));</span><br><span class="line"></span><br><span class="line">        codeBlock = jsCast&lt;ProgramCodeBlock*&gt;(tempCodeBlock);</span><br><span class="line">        <span class="built_in">ASSERT</span>(codeBlock &amp;&amp; codeBlock-&gt;<span class="built_in">numParameters</span>() == <span class="number">1</span>); <span class="comment">// 1 parameter for &#x27;this&#x27;.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RefPtr&lt;JITCode&gt; jitCode;</span><br><span class="line">    ProtoCallFrame protoCallFrame;</span><br><span class="line">    &#123;</span><br><span class="line">        DisallowGC disallowGC; <span class="comment">// Ensure no GC happens. GC can replace CodeBlock in Executable.</span></span><br><span class="line">        jitCode = program-&gt;<span class="built_in">generatedJITCode</span>();</span><br><span class="line">        protoCallFrame.<span class="built_in">init</span>(codeBlock, globalObject, globalCallee, thisObj, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute the code:</span></span><br><span class="line">    throwScope.<span class="built_in">release</span>();</span><br><span class="line">    <span class="built_in">ASSERT</span>(jitCode == program-&gt;<span class="built_in">generatedJITCode</span>().<span class="built_in">ptr</span>());</span><br><span class="line">    JSValue result = jitCode-&gt;<span class="built_in">execute</span>(&amp;vm, &amp;protoCallFrame);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">checkedReturn</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>As we can see, the <code>executeProgram</code> function calls <code>program-&gt;prepareForExecution</code> to link the <code>unlinked</code> bytecode to <code>linked</code> bytecode. </p>
<p>Let’s start analysis <code>prepareForExecution</code> function. It inner calls <code>prepareForExecutionImpl</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bytecode/CodeBlock.h:1002</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ExecutableType&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ScriptExecutable::prepareForExecution</span><span class="params">(VM&amp; vm, JSFunction* function, JSScope* scope, CodeSpecializationKind kind, CodeBlock*&amp; resultCodeBlock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">prepareForExecutionImpl</span>(vm, function, scope, kind, resultCodeBlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In <code>prepareForExecutionImpl</code> function, it perform 2 actions:</p>
<ul>
<li>calls <code>newCodeBlockFor</code> to link the <code>unlinked</code> bytecode to <code>linked</code> bytecode, and create <code>codeBlock</code> object.</li>
<li>calls <code>setupLLInt</code> function to set up the entry point to the program, which <code>LLInt</code> will start interpreter from.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/ScriptExecutable.cpp: 379</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ScriptExecutable::prepareForExecutionImpl</span><span class="params">(VM&amp; vm, JSFunction* function, JSScope* scope, CodeSpecializationKind kind, CodeBlock*&amp; resultCodeBlock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    CodeBlock* codeBlock = <span class="built_in">newCodeBlockFor</span>(kind, function, scope);</span><br><span class="line">    ...</span><br><span class="line">    resultCodeBlock = codeBlock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Options::<span class="built_in">validateBytecode</span>())</span><br><span class="line">        codeBlock-&gt;<span class="built_in">validate</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> installedUnlinkedBaselineCode = <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ENABLE(JIT)</span></span><br><span class="line">    <span class="keyword">if</span> (RefPtr&lt;BaselineJITCode&gt; baselineRef = codeBlock-&gt;<span class="built_in">unlinkedCodeBlock</span>()-&gt;m_unlinkedBaselineCode) &#123;</span><br><span class="line">        codeBlock-&gt;<span class="built_in">setupWithUnlinkedBaselineCode</span>(baselineRef.<span class="built_in">releaseNonNull</span>());</span><br><span class="line">        installedUnlinkedBaselineCode = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (!installedUnlinkedBaselineCode) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Options::<span class="built_in">useLLInt</span>())</span><br><span class="line">            <span class="built_in">setupLLInt</span>(codeBlock);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">setupJIT</span>(vm, codeBlock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">installCode</span>(vm, codeBlock, codeBlock-&gt;<span class="built_in">codeType</span>(), codeBlock-&gt;<span class="built_in">specializationKind</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Let’s first go into the <code>newCodeBlockFor</code> function to see how <code>linked</code> bytecode is generated. It will call <code>ProgramCodeBlock::create</code> to perform the generation, and the <code>create</code> function will call <code>instance-&gt;finishCreation</code> to do the action.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/ScriptExecutable.cpp: 249</span></span><br><span class="line"><span class="function">CodeBlock* <span class="title">ScriptExecutable::newCodeBlockFor</span><span class="params">(CodeSpecializationKind kind, JSFunction* function, JSScope* scope)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">classInfo</span>(vm) == ProgramExecutable::<span class="built_in">info</span>()) &#123;</span><br><span class="line">        ProgramExecutable* executable = jsCast&lt;ProgramExecutable*&gt;(<span class="keyword">this</span>);</span><br><span class="line">        <span class="built_in">RELEASE_ASSERT</span>(kind == CodeForCall);</span><br><span class="line">        <span class="built_in">RELEASE_ASSERT</span>(!executable-&gt;m_programCodeBlock);</span><br><span class="line">        <span class="built_in">RELEASE_ASSERT</span>(!function);</span><br><span class="line">        <span class="built_in">RELEASE_AND_RETURN</span>(throwScope, ProgramCodeBlock::<span class="built_in">create</span>(vm, executable, executable-&gt;m_unlinkedProgramCodeBlock.<span class="built_in">get</span>(), scope));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">		<span class="comment">// bytecode/ProgramCodeBlock.h: 56</span></span><br><span class="line">		<span class="function"><span class="keyword">static</span> ProgramCodeBlock* <span class="title">create</span><span class="params">(VM&amp; vm, ProgramExecutable* ownerExecutable, UnlinkedProgramCodeBlock* unlinkedCodeBlock, JSScope* scope)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ProgramCodeBlock* instance = <span class="built_in"><span class="keyword">new</span></span> (NotNull, allocateCell&lt;ProgramCodeBlock&gt;(vm))</span><br><span class="line">            <span class="built_in">ProgramCodeBlock</span>(vm, vm.programCodeBlockStructure.<span class="built_in">get</span>(), ownerExecutable, unlinkedCodeBlock, scope);</span><br><span class="line">        <span class="keyword">if</span> (!instance-&gt;<span class="built_in">finishCreation</span>(vm, ownerExecutable, unlinkedCodeBlock, scope))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Follow into the <code>instance-&gt;finishCreation</code> function, we can see from the comment that this function is used to generate linked bytecode from unlinked bytecode. It will traverse every <code>unlinked</code> bytecode and call <code>LINK</code> to link it the the <code>linked</code> bytecde, as well as initialize <code>metedata</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bytecode/CodeBlock.cpp: 355</span></span><br><span class="line"><span class="comment">// The main purpose of this function is to generate linked bytecode from unlinked bytecode. The process</span></span><br><span class="line"><span class="comment">// of linking is taking an abstract representation of bytecode and tying it to a GlobalObject and scope</span></span><br><span class="line"><span class="comment">// chain. For example, this process allows us to cache the depth of lexical environment reads that reach</span></span><br><span class="line"><span class="comment">// outside of this CodeBlock&#x27;s compilation unit. It also allows us to generate particular constants that</span></span><br><span class="line"><span class="comment">// we can&#x27;t generate during unlinked bytecode generation. This process is not allowed to generate control</span></span><br><span class="line"><span class="comment">// flow or introduce new locals. The reason for this is we rely on liveness analysis to be the same for</span></span><br><span class="line"><span class="comment">// all the CodeBlocks of an UnlinkedCodeBlock. We rely on this fact by caching the liveness analysis</span></span><br><span class="line"><span class="comment">// inside UnlinkedCodeBlock. Also, Baseline JIT code is shared between all CodeBlocks of an UnlinkedCodeBlock,</span></span><br><span class="line"><span class="comment">// so the bytecode must remain the same between CodeBlocks sharing an UnlinkedCodeBlock.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CodeBlock::finishCreation</span><span class="params">(VM&amp; vm, ScriptExecutable* ownerExecutable, UnlinkedCodeBlock* unlinkedCodeBlock,</span></span></span><br><span class="line"><span class="params"><span class="function">    JSScope* scope)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINK_FIELD(__field) \</span></span><br><span class="line"><span class="meta">    WTF_LAZY_JOIN(link_, __field)(instruction, bytecode, metadata);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INITIALIZE_METADATA(__op) \</span></span><br><span class="line"><span class="meta">    auto bytecode = instruction-&gt;as<span class="meta-string">&lt;__op&gt;</span>(); \</span></span><br><span class="line"><span class="meta">    auto&amp; metadata = bytecode.metadata(this); \</span></span><br><span class="line"><span class="meta">    new (&amp;metadata) __op::Metadata &#123; bytecode &#125;; \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINK_IMPL(...) \</span></span><br><span class="line"><span class="meta">        INITIALIZE_METADATA(WTF_LAZY_FIRST(__VA_ARGS__)) \</span></span><br><span class="line"><span class="meta">        WTF_LAZY_HAS_REST(__VA_ARGS__)(&#123; \</span></span><br><span class="line"><span class="meta">            WTF_LAZY_FOR_EACH_TERM(LINK_FIELD,  WTF_LAZY_REST_(__VA_ARGS__)) \</span></span><br><span class="line"><span class="meta">        &#125;) \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CASE(__op) case __op::opcodeID</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINK(...) \</span></span><br><span class="line"><span class="meta">    CASE(WTF_LAZY_FIRST(__VA_ARGS__)): &#123; \</span></span><br><span class="line"><span class="meta">        LINK_IMPL(__VA_ARGS__) \</span></span><br><span class="line"><span class="meta">        break; \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">const</span> InstructionStream&amp; instructionStream = <span class="built_in">instructions</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; instruction : instructionStream) &#123;</span><br><span class="line">        OpcodeID opcodeID = instruction-&gt;<span class="built_in">opcodeID</span>();</span><br><span class="line">        m_bytecodeCost += opcodeLengths[opcodeID];</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (opcodeID) &#123;</span><br><span class="line">        <span class="built_in">LINK</span>(OpGetByVal, profile)</span><br><span class="line">        <span class="built_in">LINK</span>(OpGetPrivateName, profile)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">LINK</span>(OpGetByIdWithThis, profile)</span><br><span class="line">        <span class="built_in">LINK</span>(OpTryGetById, profile)</span><br><span class="line">        <span class="built_in">LINK</span>(OpGetByIdDirect, profile)</span><br></pre></td></tr></table></figure>

<p>When finished the generation of <code>linked</code> bytecode, <code>jsc</code> goes back to <code>prepareForExecutionImpl</code> function, and <code>prepareForExecutionImpl</code> then calls <code>setupLLInt</code> function which eventually calls <code>setProgramEntrypoint</code> to set up the entry point to the program for the <code>LLInt</code> to being executing from.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/ScriptExecutable.cpp: 362</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setupLLInt</span><span class="params">(CodeBlock* codeBlock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LLInt::<span class="built_in">setEntrypoint</span>(codeBlock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// llint/LLIntEntrypoint.cpp: 229</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setEntrypoint</span><span class="params">(CodeBlock* codeBlock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (codeBlock-&gt;<span class="built_in">codeType</span>()) &#123;</span><br><span class="line">    <span class="keyword">case</span> GlobalCode:</span><br><span class="line">        <span class="built_in">setProgramEntrypoint</span>(codeBlock);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// llint/LLIntEntrypoint.cpp: 139</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setProgramEntrypoint</span><span class="params">(CodeBlock* codeBlock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ENABLE(JIT)</span></span><br><span class="line">    <span class="keyword">if</span> (Options::<span class="built_in">useJIT</span>()) &#123;</span><br><span class="line">        <span class="keyword">static</span> NativeJITCode* jitCode;</span><br><span class="line">        <span class="keyword">static</span> std::once_flag onceKey;</span><br><span class="line">        std::<span class="built_in">call_once</span>(onceKey, [&amp;] &#123;</span><br><span class="line">            MacroAssemblerCodeRef&lt;JSEntryPtrTag&gt; codeRef = <span class="built_in">programEntryThunk</span>();</span><br><span class="line">            jitCode = <span class="keyword">new</span> <span class="built_in">NativeJITCode</span>(codeRef, JITType::InterpreterThunk, Intrinsic::NoIntrinsic, JITCode::ShareAttribute::Shared);</span><br><span class="line">        &#125;);</span><br><span class="line">        codeBlock-&gt;<span class="built_in">setJITCode</span>(*jitCode);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Right now, we get the <code>linked</code> bytecode and also set up the entry point for the LLInt, we can continue to move to the next step.</p>
<h2 id="Ready-to-execute-bytecode"><a href="#Ready-to-execute-bytecode" class="headerlink" title="Ready to execute bytecode"></a>Ready to execute bytecode</h2><p>As we can see from the code, when <code>prepareForExecution</code> function finishes the generation of <code>linked</code> bytecode, the <code>executeProgram</code> function will calls <code>generatedJITCode</code> and <code>protoCallFrame.init</code> to make the final preparations for running the interpreter.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interpreter/Interpreter.cpp: 709</span></span><br><span class="line"><span class="function">JSValue <span class="title">Interpreter::executeProgram</span><span class="params">(<span class="keyword">const</span> SourceCode&amp; source, JSGlobalObject*, JSObject* thisObj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    JSObject* error = program-&gt;<span class="built_in">initializeGlobalProperties</span>(vm, globalObject, scope);</span><br><span class="line">    ...</span><br><span class="line">        program-&gt;prepareForExecution&lt;ProgramExecutable&gt;(vm, <span class="literal">nullptr</span>, scope, CodeForCall, tempCodeBlock);</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    RefPtr&lt;JITCode&gt; jitCode;</span><br><span class="line">    ProtoCallFrame protoCallFrame;</span><br><span class="line">    &#123;</span><br><span class="line">        DisallowGC disallowGC; <span class="comment">// Ensure no GC happens. GC can replace CodeBlock in Executable.</span></span><br><span class="line">        jitCode = program-&gt;<span class="built_in">generatedJITCode</span>();</span><br><span class="line">        protoCallFrame.<span class="built_in">init</span>(codeBlock, globalObject, globalCallee, thisObj, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute the code:</span></span><br><span class="line">    throwScope.<span class="built_in">release</span>();</span><br><span class="line">    <span class="built_in">ASSERT</span>(jitCode == program-&gt;<span class="built_in">generatedJITCode</span>().<span class="built_in">ptr</span>());</span><br><span class="line">    JSValue result = jitCode-&gt;<span class="built_in">execute</span>(&amp;vm, &amp;protoCallFrame);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">checkedReturn</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>generatedJITCode</code> returns a reference pointer to the interpreted code, which is used to start running the interpreter.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// runtime/ProgramExecutable.h: 62</span></span><br><span class="line"><span class="function">Ref&lt;JITCode&gt; <span class="title">generatedJITCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">generatedJITCodeForCall</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runtime/ProgramExecutable.h: 113</span></span><br><span class="line">  <span class="function">Ref&lt;JITCode&gt; <span class="title">generatedJITCodeForCall</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="built_in">ASSERT</span>(m_jitCodeForCall);</span><br><span class="line">      <span class="keyword">return</span> *m_jitCodeForCall;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><code>protoCallFrame.init</code> initialize a <code>ProtoCallFrame</code> with the generated <code>codeBlock</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interpreter/ProtoCallFrameInlined.h: 33</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ProtoCallFrame::init</span><span class="params">(CodeBlock* codeBlock, JSGlobalObject* globalObject, JSObject* callee, JSValue thisValue, <span class="keyword">int</span> argCountIncludingThis, JSValue* otherArgs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;args = otherArgs;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setCodeBlock</span>(codeBlock);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setCallee</span>(callee);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setGlobalObject</span>(globalObject);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setArgumentCountIncludingThis</span>(argCountIncludingThis);</span><br><span class="line">    <span class="keyword">if</span> (codeBlock &amp;&amp; <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span>&gt;(argCountIncludingThis) &lt; codeBlock-&gt;<span class="built_in">numParameters</span>())</span><br><span class="line">        <span class="keyword">this</span>-&gt;hasArityMismatch = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;hasArityMismatch = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Round up argCountIncludingThis to keep the stack frame size aligned.</span></span><br><span class="line">    <span class="keyword">size_t</span> paddedArgsCount = <span class="built_in">roundArgumentCountToAlignFrame</span>(argCountIncludingThis);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setPaddedArgCount</span>(paddedArgsCount);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">clearCurrentVPC</span>();</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setThisValue</span>(thisValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now that everything is ready, it will call <code>JSValue result = jitCode-&gt;execute(&amp;vm, &amp;protoCallFrame);</code> to <code>execute</code> the <code>linked</code> bytecode, but this should be explained in the next post.</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>In this post, we have finished the analysis of how the jsc compile js source to the bytecode. </p>
<p>Specifially, it first set up the runtime, and then parse the source to <code>AST</code> tree, and generate the <code>unlinked</code> bytecode with <code>AST</code> tree, and then links the <code>unlinked</code> bytecode to <code>linked</code> bytecode and finally sets up the entry point for running. Now all the things are ready, we can start to interpreter the bytecode.</p>
<p>I learned a lot from this process, most importantly, it helps me to get a deeper understanding of the jsc code. In the next part, i’ll try to explain the way that jsc interpreter the bytecode.</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a target="_blank" rel="noopener" href="https://zon8.re/posts/jsc-internals-part1-tracing-js-source-to-bytecode/">JavaScriptCore Internals Part I: Tracing JavaScript Source to Bytecode</a></li>
<li><a target="_blank" rel="noopener" href="https://webkit.org/blog/9329/a-new-bytecode-format-for-javascriptcore/">A New Bytecode Format for JavaScriptCore</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/11/2021-12-11-JSC-Internal-From-JS-Source-To-Bytecode/" data-id="ckx47unuy00004mrw3ss721zb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jsc/" rel="tag">jsc</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/12/12/hello-world/" id="article-nav-newer" class="article-nav-link-wrap">
      <span class="article-nav-caption">Newer</span>
      <div class="article-nav-title">
        
          Hello World
        
      </div>
    </a>
  
  
</nav>

  
</article>

</section>
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 fchain7<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> with 
      theme_by <a href="http://hexo.io/" target="_blank">mango</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives/" class="mobile-nav-link">Archives</a>
  
    <a href="/about/" class="mobile-nav-link">about</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>